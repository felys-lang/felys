# ! [doc = "Generated by PhiLia093"] use std :: collections :: HashSet ; # [allow (unused)] pub struct Packrat { pub __intern : super :: Intern , pub __memo : super :: Memo , pub __stream : super :: Stream , pub __keywords : HashSet < & 'static str > , pub __snapshot : Option < (usize , & 'static str) > , } impl From < String > for Packrat { fn from (value : String) -> Self { Self { __intern : super :: Intern :: default () , __memo : super :: Memo :: default () , __stream : super :: Stream :: from (value) , __keywords : HashSet :: from ([]) , __snapshot : None , } } } pub type Rules < T , const S : usize > = [fn (& mut Packrat) -> Option < T > ; S] ; # [allow (unused)] impl Packrat { pub fn __expect (& mut self , s : & 'static str) -> Option < & 'static str > { if self . __snapshot . is_some () { return None ; } let start = self . __stream . cursor ; let result = s . chars () . all (| c | self . __stream . next () == Some (c)) . then_some (s) ; if result . is_none () { self . __stream . cursor = start ; } result } pub fn __attempt < T > (& mut self , f : fn (& mut Packrat) -> Option < T >) -> Option < T > { let start = self . __stream . cursor ; let result = f (self) ; if result . is_none () { self . __stream . cursor = start ; } result } pub fn __peg < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { rules . iter () . filter_map (| rule | self . __attempt (* rule)) . next () } pub fn __error < T > (& mut self , msg : & 'static str) -> Option < T > { if self . __snapshot . is_some () { return None ; } let cursor = self . __stream . cursor ; self . __snapshot = Some ((cursor , msg)) ; None } pub fn __lookahead < T > (& mut self , f : fn (& mut Packrat) -> Option < T > , behavior : bool) -> Option < () > { let start = self . __stream . cursor ; let snapshot = self . __snapshot ; let result = f (self) ; self . __stream . cursor = start ; self . __snapshot = snapshot ; if result . is_some () == behavior { Some (()) } else { None } } }