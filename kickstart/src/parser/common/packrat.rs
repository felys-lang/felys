# ! [doc = "Generated by rspegen"] use std :: collections :: HashSet ; # [allow (unused)] pub struct Packrat { pub intern : super :: Intern , pub memo : super :: Memo , pub stream : super :: Stream , pub keywords : HashSet < & 'static str > , pub snapshot : Option < (usize , & 'static str) > , } impl From < String > for Packrat { fn from (value : String) -> Self { Self { intern : super :: Intern :: default () , memo : super :: Memo :: default () , stream : super :: Stream :: from (value) , keywords : HashSet :: from (["->" , ":" , ";" , ":" , ";" , "{" , ":" , ";" , "}" , "@" , "(" , "," , ")" , "memo" , "left" , "token" , "intern" , "ws" , "/" , "/" , "=" , "$" , "&" , "!" , "?" , "*" , "#" , "+" , "#" , "(" , ")" , "|" , "+" , "*" , "(" , ")" , "[" , "^" , "]" , "[" , "]" , "'" , "'" , "-"]) , snapshot : None , } } } pub type Rules < T , const S : usize > = [fn (& mut Packrat) -> Option < T > ; S] ; # [allow (unused)] impl Packrat { pub fn __expect (& mut self , s : & 'static str) -> Option < & 'static str > { if self . snapshot . is_some () { return None ; } let start = self . stream . cursor ; self . stream . trim () ; let result = s . chars () . all (| c | self . stream . next () == Some (c)) . then_some (s) ; if result . is_none () { self . stream . cursor = start ; } result } pub fn __attempt < T > (& mut self , f : fn (& mut Packrat) -> Option < T >) -> Option < T > { let start = self . stream . cursor ; let result = f (self) ; if result . is_none () { self . stream . cursor = start ; } result } pub fn __rule < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { rules . iter () . filter_map (| rule | self . __attempt (* rule)) . next () } pub fn __token < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { self . stream . trim () ; let strict = self . stream . strict ; self . stream . strict = true ; let result = self . __rule (rules) ; self . stream . strict = strict ; result } pub fn __error < T > (& mut self , msg : & 'static str) -> Option < T > { if self . snapshot . is_some () { return None ; } let cursor = self . stream . cursor ; self . snapshot = Some ((cursor , msg)) ; None } pub fn __lookahead < T > (& mut self , f : fn (& mut Packrat) -> Option < T > , behavior : bool) -> Option < () > { let start = self . stream . cursor ; let snapshot = self . snapshot ; let result = f (self) ; self . stream . cursor = start ; self . snapshot = snapshot ; if result . is_some () == behavior { Some (()) } else { None } } }