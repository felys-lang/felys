# ! [doc = "Generated by kickstart"] use crate :: ast ::*; # [allow (unused)] use crate :: utils ::*; # [allow (clippy :: double_parens , clippy :: let_unit_value)] # [allow (non_snake_case , unused)] impl super :: Packrat { pub fn grammar (& mut self) -> Option < Grammar > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Grammar , 1usize > = [| x | { let import = x . ACTION () ; x . memo . clean () ; let callables = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let callable = x . callable () ? ; x . memo . clean () ; Some ((callable)) }]) { body . push (data) } body } ; let _ = match x . eof () { Some (value) => value , None => return x . __error ("<eof>") , } ; Some (Grammar { import , callables }) }] ; self . __peg (RULES) } pub fn callable (& mut self) -> Option < Callable > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Callable , 2usize > = [| x | { let deco = x . deco () ; let prefix = x . PREFIX () ? ; let name = match x . NAME () { Some (value) => value , None => return x . __error ("<NAME>") , } ; let ty = x . __peg ([| x | { let _ = x . __expect ("->") ? ; let ty = match x . ACTION () { Some (value) => value , None => return x . __error ("<ACTION>") , } ; Some ((ty)) }]) ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let rule = match x . rule () { Some (value) => value , None => return x . __error ("<rule>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some (Callable :: Rule (deco , prefix , name , ty , rule)) } , | x | { let deco = x . deco () ; let name = x . NAME () ? ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some (Callable :: Regex (deco , name , regex)) }] ; self . __peg (RULES) } pub fn deco (& mut self) -> Option < BufVec < Tag , 1 > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < BufVec < Tag , 1 > , 1usize > = [| x | { let _ = x . __expect ("@") ? ; let _ = match x . __expect ("(") { Some (value) => value , None => return x . __error ("'('") , } ; let first = match x . tag () { Some (value) => value , None => return x . __error ("<tag>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let tag = match x . tag () { Some (value) => value , None => return x . __error ("<tag>") , } ; Some ((tag)) }]) { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (BufVec :: new ([first] , more)) }] ; self . __peg (RULES) } pub fn tag (& mut self) -> Option < Tag > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Tag , 3usize > = [| x | { let _ = x . __expect ("memo") ? ; Some (Tag :: Memo) } , | x | { let _ = x . __expect ("left") ? ; Some (Tag :: Left) } , | x | { let _ = x . __expect ("ws") ? ; Some (Tag :: Whitespace) }] ; self . __peg (RULES) } pub fn rule (& mut self) -> Option < Rule > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Rule , 1usize > = [| x | { let _ = x . __expect ("/") ; let first = match x . alter () { Some (value) => value , None => return x . __error ("<alter>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect ("/") ? ; let alter = match x . alter () { Some (value) => value , None => return x . __error ("<alter>") , } ; Some ((alter)) }]) { body . push (data) } body } ; Some (Rule { first , more }) }] ; self . __peg (RULES) } pub fn alter (& mut self) -> Option < Alter > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Alter , 1usize > = [| x | { let first = match x . assignment () { Some (value) => value , None => return x . __error ("<assignment>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . assignment () { body . push (data) } body } ; let action = x . ACTION () ; Some (Alter { assignments : BufVec :: new ([first] , more) , action , }) }] ; self . __peg (RULES) } pub fn assignment (& mut self) -> Option < Assignment > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Assignment , 4usize > = [| x | { let name = x . NAME () ? ; let _ = x . __expect ("=") ? ; let item = match x . item () { Some (value) => value , None => return x . __error ("<item>") , } ; Some (Assignment :: Named (name , item)) } , | x | { let lookahead = x . lookahead () ? ; Some (Assignment :: Lookahead (lookahead)) } , | x | { let item = x . item () ? ; Some (Assignment :: Anonymous (item)) } , | x | { let _ = x . __expect ("$") ? ; Some (Assignment :: Clean) }] ; self . __peg (RULES) } pub fn lookahead (& mut self) -> Option < Lookahead > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Lookahead , 2usize > = [| x | { let _ = x . __expect ("&") ? ; let atom = match x . atom () { Some (value) => value , None => return x . __error ("<atom>") , } ; Some (Lookahead :: Positive (atom)) } , | x | { let _ = x . __expect ("!") ? ; let atom = match x . atom () { Some (value) => value , None => return x . __error ("<atom>") , } ; Some (Lookahead :: Negative (atom)) }] ; self . __peg (RULES) } pub fn item (& mut self) -> Option < Item > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Item , 4usize > = [| x | { let _ = x . __expect ("[") ? ; let atom = match x . atom () { Some (value) => value , None => return x . __error ("<atom>") , } ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; let msg = x . MESSAGE () ; Some (Item :: Eager (atom , msg)) } , | x | { let atom = x . atom () ? ; let _ = x . __expect ("?") ? ; Some (Item :: Optional (atom)) } , | x | { let atom = x . atom () ? ; let _ = x . __expect ("*") ? ; Some (Item :: Repetition (atom)) } , | x | { let atom = x . atom () ? ; Some (Item :: Name (atom)) }] ; self . __peg (RULES) } pub fn atom (& mut self) -> Option < Atom > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Atom , 3usize > = [| x | { let _ = x . __expect ("(") ? ; let rule = match x . rule () { Some (value) => value , None => return x . __error ("<rule>") , } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Atom :: Nested (rule)) } , | x | { let expect = x . EXPECT () ? ; Some (Atom :: Expect (expect)) } , | x | { let name = x . NAME () ? ; Some (Atom :: Name (name)) }] ; self . __peg (RULES) } pub fn union (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 2usize > = [| x | { let lhs = x . union () ? ; let _ = x . __expect ("|") ? ; let rhs = match x . concat () { Some (value) => value , None => return x . __error ("<concat>") , } ; Some (Regex :: Union (lhs . into () , rhs . into ())) } , | x | { let concat = x . concat () ? ; Some (concat) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . union . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . union . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . union . insert ((start , strict) , (end , cache)) ; result } pub fn concat (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 2usize > = [| x | { let lhs = x . concat () ? ; let rhs = x . repeat () ? ; Some (Regex :: Concat (lhs . into () , rhs . into ())) } , | x | { let repeat = x . repeat () ? ; Some (repeat) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . concat . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . concat . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . concat . insert ((start , strict) , (end , cache)) ; result } pub fn repeat (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 3usize > = [| x | { let inner = x . repeat () ? ; let _ = x . __expect ("+") ? ; Some (Regex :: OnceOrMore (inner . into ())) } , | x | { let inner = x . repeat () ? ; let _ = x . __expect ("*") ? ; Some (Regex :: ZeroOrMore (inner . into ())) } , | x | { let primary = x . primary () ? ; Some (Regex :: Primary (primary)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . repeat . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . repeat . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . repeat . insert ((start , strict) , (end , cache)) ; result } pub fn primary (& mut self) -> Option < Primary > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Primary , 4usize > = [| x | { let _ = x . __expect ("(") ? ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Primary :: Parentheses (regex . into ())) } , | x | { let string = x . STRING () ? ; Some (Primary :: Literal (string)) } , | x | { let name = x . NAME () ? ; Some (Primary :: Name (name)) } , | x | { let set = x . SET () ? ; Some (set) }] ; self . __peg (RULES) } pub fn PREFIX (& mut self) -> Option < Prefix > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Prefix , 2usize > = [| x | { let _ = x . __expect ("peg") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Prefix :: Peg) } , | x | { let _ = x . __expect ("lex") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Prefix :: Lex) }] ; self . __lex (RULES) } pub fn SET (& mut self) -> Option < Primary > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Primary , 2usize > = [| x | { let _ = x . __expect ("[") ? ; let _ = x . __expect ("^") ? ; let first = match x . RANGE () { Some (value) => value , None => return x . __error ("<RANGE>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . RANGE () { body . push (data) } body } ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; Some (Primary :: Exclude (BufVec :: new ([first] , more))) } , | x | { let _ = x . __expect ("[") ? ; let first = match x . RANGE () { Some (value) => value , None => return x . __error ("<RANGE>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . RANGE () { body . push (data) } body } ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; Some (Primary :: Include (BufVec :: new ([first] , more))) }] ; self . __lex (RULES) } pub fn EXPECT (& mut self) -> Option < Expect > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expect , 2usize > = [| x | { let _ = x . __expect ("'") ? ; let first = match x . SQC () { Some (value) => value , None => return x . __error ("<SQC>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . SQC () { body . push (data) } body } ; let _ = match x . __expect ("'") { Some (value) => value , None => return x . __error ("'''") , } ; Some (Expect :: Once (BufVec :: new ([first] , more))) } , | x | { let _ = x . __expect ("\"") ? ; let first = match x . DQC () { Some (value) => value , None => return x . __error ("<DQC>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . DQC () { body . push (data) } body } ; let _ = match x . __expect ("\"") { Some (value) => value , None => return x . __error ("'\"'") , } ; Some (Expect :: Keyword (BufVec :: new ([first] , more))) }] ; self . __lex (RULES) } pub fn STRING (& mut self) -> Option < BufVec < usize , 1 > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < BufVec < usize , 1 > , 1usize > = [| x | { let _ = x . __expect ("'") ? ; let first = match x . SQC () { Some (value) => value , None => return x . __error ("<SQC>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . SQC () { body . push (data) } body } ; let _ = match x . __expect ("'") { Some (value) => value , None => return x . __error ("'''") , } ; Some (BufVec :: new ([first] , more)) }] ; self . __lex (RULES) } pub fn RANGE (& mut self) -> Option < (usize , usize) > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < (usize , usize) , 2usize > = [| x | { let start = x . BC () ? ; let _ = x . __expect ("-") ? ; let end = match x . BC () { Some (value) => value , None => return x . __error ("<BC>") , } ; Some ((start , end)) } , | x | { let ch = x . BC () ? ; Some ((ch , ch)) }] ; self . __lex (RULES) } pub fn MESSAGE (& mut self) -> Option < Message > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Message , 1usize > = [| x | { let _ = x . __expect ("(") ? ; let msg = { let mut body = Vec :: new () ; while let Some (data) = x . MSG () { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Message (msg)) }] ; self . __lex (RULES) } pub fn MSG (& mut self) -> Option < Nested > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Nested , 2usize > = [| x | { let _ = x . __expect ("(") ? ; let msg = { let mut body = Vec :: new () ; while let Some (data) = x . MSG () { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Nested :: Inner (msg)) } , | x | { let msg = x . PS () ? ; Some (Nested :: Segment (msg)) }] ; self . __lex (RULES) } pub fn ACTION (& mut self) -> Option < Action > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Action , 1usize > = [| x | { let _ = x . __expect ("{") ? ; let act = { let mut body = Vec :: new () ; while let Some (data) = x . ACT () { body . push (data) } body } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Action (act)) }] ; self . __lex (RULES) } pub fn ACT (& mut self) -> Option < Nested > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Nested , 2usize > = [| x | { let _ = x . __expect ("{") ? ; let act = { let mut body = Vec :: new () ; while let Some (data) = x . ACT () { body . push (data) } body } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Nested :: Inner (act)) } , | x | { let act = x . BS () ? ; Some (Nested :: Segment (act)) }] ; self . __lex (RULES) } pub fn NAME (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some (& (end , cache)) = self . memo . NAME . get (& (start , strict)) { self . stream . cursor = end ; return cache ; } self . stream . trim () ; let result = self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) ; let end = self . stream . cursor ; self . memo . NAME . insert ((start , strict) , (end , result)) ; result } pub fn TAIL (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 57usize) => 1usize , (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn DQC (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 33usize) => 1usize , (0usize , 35usize ..= 91usize) => 1usize , (0usize , 92usize ..= 92usize) => 2usize , (0usize , 93usize ..= 18446744073709551615usize) => 1usize , (2usize , 34usize ..= 34usize) => 1usize , (2usize , 39usize ..= 39usize) => 1usize , (2usize , 91usize ..= 91usize) => 1usize , (2usize , 92usize ..= 92usize) => 1usize , (2usize , 93usize ..= 93usize) => 1usize , (2usize , 110usize ..= 110usize) => 1usize , (2usize , 114usize ..= 114usize) => 1usize , (2usize , 116usize ..= 116usize) => 1usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 123usize ..= 123usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (4usize , 97usize ..= 102usize) => 4usize , (4usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , true , false , false , false] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn SQC (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 38usize) => 1usize , (0usize , 40usize ..= 91usize) => 1usize , (0usize , 92usize ..= 92usize) => 2usize , (0usize , 93usize ..= 18446744073709551615usize) => 1usize , (2usize , 34usize ..= 34usize) => 1usize , (2usize , 39usize ..= 39usize) => 1usize , (2usize , 91usize ..= 91usize) => 1usize , (2usize , 92usize ..= 92usize) => 1usize , (2usize , 93usize ..= 93usize) => 1usize , (2usize , 110usize ..= 110usize) => 1usize , (2usize , 114usize ..= 114usize) => 1usize , (2usize , 116usize ..= 116usize) => 1usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 123usize ..= 123usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (4usize , 97usize ..= 102usize) => 4usize , (4usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , true , false , false , false] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn BC (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 91usize) => 1usize , (0usize , 92usize ..= 92usize) => 2usize , (0usize , 94usize ..= 18446744073709551615usize) => 1usize , (2usize , 34usize ..= 34usize) => 1usize , (2usize , 39usize ..= 39usize) => 1usize , (2usize , 91usize ..= 91usize) => 1usize , (2usize , 92usize ..= 92usize) => 1usize , (2usize , 93usize ..= 93usize) => 1usize , (2usize , 110usize ..= 110usize) => 1usize , (2usize , 114usize ..= 114usize) => 1usize , (2usize , 116usize ..= 116usize) => 1usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 123usize ..= 123usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (4usize , 97usize ..= 102usize) => 4usize , (4usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , true , false , false , false] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn UNICODE (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 92usize ..= 92usize) => 1usize , (1usize , 117usize ..= 117usize) => 2usize , (2usize , 123usize ..= 123usize) => 3usize , (3usize , 48usize ..= 57usize) => 3usize , (3usize , 97usize ..= 102usize) => 3usize , (3usize , 125usize ..= 125usize) => 4usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn ESCAPE (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 92usize ..= 92usize) => 1usize , (1usize , 34usize ..= 34usize) => 2usize , (1usize , 39usize ..= 39usize) => 2usize , (1usize , 91usize ..= 91usize) => 2usize , (1usize , 92usize ..= 92usize) => 2usize , (1usize , 93usize ..= 93usize) => 2usize , (1usize , 110usize ..= 110usize) => 2usize , (1usize , 114usize ..= 114usize) => 2usize , (1usize , 116usize ..= 116usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn PS (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 39usize) => 1usize , (0usize , 42usize ..= 18446744073709551615usize) => 1usize , (1usize , 0usize ..= 39usize) => 1usize , (1usize , 42usize ..= 18446744073709551615usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn BS (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 122usize) => 1usize , (0usize , 124usize ..= 124usize) => 1usize , (0usize , 126usize ..= 18446744073709551615usize) => 1usize , (1usize , 0usize ..= 122usize) => 1usize , (1usize , 124usize ..= 124usize) => 1usize , (1usize , 126usize ..= 18446744073709551615usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn WS (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn COMMENT (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } } # [allow (unused)] impl super :: Stream { pub fn trim (& mut self) { if self . strict { return ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; loop { if self . dfa (transition , ACCEPTANCE) . is_none () { break ; } } } }