# ! [doc = "Generated by rspegen"] use crate :: ast ::*; # [allow (clippy :: double_parens , clippy :: let_unit_value)] # [allow (non_snake_case , unused)] impl super :: Packrat { pub fn grammar (& mut self) -> Option < Grammar > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Grammar , 1usize > = [| x | { let import = x . action () ; x . memo . clean () ; let callables = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let callable = x . callable () ? ; x . memo . clean () ; Some ((callable)) }]) { body . push (data) } body } ; let _ = match x . eof () { Some (value) => value , None => return x . __error ("<eof>") , } ; Some (Grammar { import , callables }) }] ; self . __peg (RULES) } pub fn callable (& mut self) -> Option < Callable > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Callable , 3usize > = [| x | { let decorator = x . decorator () ; let prefix = x . prefix () ? ; let name = match x . NAME () { Some (value) => value , None => return x . __error ("<NAME>") , } ; let _ = match x . __expect ("->") { Some (value) => value , None => return x . __error ("'->'") , } ; let ty = match x . action () { Some (value) => value , None => return x . __error ("<action>") , } ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let rule = match x . rule () { Some (value) => value , None => return x . __error ("<rule>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some (Callable :: Rule (decorator , prefix , name , ty , rule)) } , | x | { let decorator = x . decorator () ; let name = x . NAME () ? ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some (Callable :: Regex (decorator , name , regex)) } , | x | { let decorator = x . decorator () ? ; let _ = match x . __expect ("{") { Some (value) => value , None => return x . __error ("'{'") , } ; let shared = { let first = match x . __peg ([| x | { let name = x . NAME () ? ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some ((name , regex)) }]) { Some (value) => value , None => return x . __error ("???") , } ; let mut body = Vec :: from ([first]) ; while let Some (data) = x . __peg ([| x | { let name = x . NAME () ? ; let _ = match x . __expect (":") { Some (value) => value , None => return x . __error ("':'") , } ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (";") { Some (value) => value , None => return x . __error ("';'") , } ; Some ((name , regex)) }]) { body . push (data) } body } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Callable :: Shared (decorator , shared)) }] ; self . __peg (RULES) } pub fn prefix (& mut self) -> Option < Prefix > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Prefix , 2usize > = [| x | { let _ = x . __expect ("peg") ? ; Some (Prefix :: Peg) } , | x | { let _ = x . __expect ("lex") ? ; Some (Prefix :: Lex) }] ; self . __peg (RULES) } pub fn decorator (& mut self) -> Option < Decorator > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Decorator , 1usize > = [| x | { let _ = x . __expect ("@") ? ; let _ = match x . __expect ("(") { Some (value) => value , None => return x . __error ("'('") , } ; let first = match x . tag () { Some (value) => value , None => return x . __error ("<tag>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let tag = match x . tag () { Some (value) => value , None => return x . __error ("<tag>") , } ; Some ((tag)) }]) { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Decorator { first , more }) }] ; self . __peg (RULES) } pub fn tag (& mut self) -> Option < Tag > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Tag , 4usize > = [| x | { let _ = x . __expect ("memo") ? ; Some (Tag :: Memo) } , | x | { let _ = x . __expect ("left") ? ; Some (Tag :: Left) } , | x | { let _ = x . __expect ("intern") ? ; Some (Tag :: Intern) } , | x | { let _ = x . __expect ("ws") ? ; Some (Tag :: Whitespace) }] ; self . __peg (RULES) } pub fn rule (& mut self) -> Option < Rule > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Rule , 1usize > = [| x | { let _ = x . __expect ("/") ; let first = match x . alter () { Some (value) => value , None => return x . __error ("<alter>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect ("/") ? ; let alter = match x . alter () { Some (value) => value , None => return x . __error ("<alter>") , } ; Some ((alter)) }]) { body . push (data) } body } ; Some (Rule { first , more }) }] ; self . __peg (RULES) } pub fn alter (& mut self) -> Option < Alter > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Alter , 1usize > = [| x | { let assignments = { let first = match x . assignment () { Some (value) => value , None => return x . __error ("<assignment>") , } ; let mut body = Vec :: from ([first]) ; while let Some (data) = x . assignment () { body . push (data) } body } ; let action = x . action () ; Some (Alter { assignments , action }) }] ; self . __peg (RULES) } pub fn assignment (& mut self) -> Option < Assignment > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Assignment , 4usize > = [| x | { let name = x . NAME () ? ; let _ = x . __expect ("=") ? ; let item = match x . item () { Some (value) => value , None => return x . __error ("<item>") , } ; Some (Assignment :: Named (name , item)) } , | x | { let lookahead = x . lookahead () ? ; Some (Assignment :: Lookahead (lookahead)) } , | x | { let item = x . item () ? ; Some (Assignment :: Anonymous (item)) } , | x | { let _ = x . __expect ("$") ? ; Some (Assignment :: Clean) }] ; self . __peg (RULES) } pub fn lookahead (& mut self) -> Option < Lookahead > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Lookahead , 2usize > = [| x | { let _ = x . __expect ("&") ? ; let atom = match x . atom () { Some (value) => value , None => return x . __error ("<atom>") , } ; Some (Lookahead :: Positive (atom)) } , | x | { let _ = x . __expect ("!") ? ; let atom = match x . atom () { Some (value) => value , None => return x . __error ("<atom>") , } ; Some (Lookahead :: Negative (atom)) }] ; self . __peg (RULES) } pub fn item (& mut self) -> Option < Item > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Item , 4usize > = [| x | { let atom = x . atom () ? ; let _ = x . __expect ("?") ? ; Some (Item :: Optional (atom)) } , | x | { let atom = x . atom () ? ; let _ = x . __expect ("*") ? ; Some (Item :: ZeroOrMore (atom)) } , | x | { let eager = x . __expect ("#") ; let atom = x . atom () ? ; let _ = x . __expect ("+") ? ; Some (Item :: OnceOrMore (eager . is_some () , atom)) } , | x | { let eager = x . __expect ("#") ; let atom = x . atom () ? ; Some (Item :: Name (eager . is_some () , atom)) }] ; self . __peg (RULES) } pub fn atom (& mut self) -> Option < Atom > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Atom , 3usize > = [| x | { let _ = x . __expect ("(") ? ; let rule = match x . rule () { Some (value) => value , None => return x . __error ("<rule>") , } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Atom :: Nested (rule)) } , | x | { let string = x . STRING () ? ; Some (Atom :: String (string)) } , | x | { let name = x . NAME () ? ; Some (Atom :: Name (name)) }] ; self . __peg (RULES) } pub fn union (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 2usize > = [| x | { let lhs = x . union () ? ; let _ = x . __expect ("|") ? ; let rhs = match x . concat () { Some (value) => value , None => return x . __error ("<concat>") , } ; Some (Regex :: Union (lhs . into () , rhs . into ())) } , | x | { let concat = x . concat () ? ; Some (concat) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . union . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . union . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . union . insert ((start , strict) , (end , cache)) ; result } pub fn concat (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 2usize > = [| x | { let lhs = x . concat () ? ; let rhs = x . repeat () ? ; Some (Regex :: Concat (lhs . into () , rhs . into ())) } , | x | { let repeat = x . repeat () ? ; Some (repeat) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . concat . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . concat . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . concat . insert ((start , strict) , (end , cache)) ; result } pub fn repeat (& mut self) -> Option < Regex > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Regex , 3usize > = [| x | { let inner = x . repeat () ? ; let _ = x . __expect ("+") ? ; Some (Regex :: OnceOrMore (inner . into ())) } , | x | { let inner = x . repeat () ? ; let _ = x . __expect ("*") ? ; Some (Regex :: ZeroOrMore (inner . into ())) } , | x | { let primary = x . primary () ? ; Some (Regex :: Primary (primary)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . repeat . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . repeat . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . repeat . insert ((start , strict) , (end , cache)) ; result } pub fn primary (& mut self) -> Option < Primary > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Primary , 4usize > = [| x | { let _ = x . __expect ("(") ? ; let regex = match x . union () { Some (value) => value , None => return x . __error ("<union>") , } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Primary :: Parentheses (regex . into ())) } , | x | { let string = x . STRING () ? ; Some (Primary :: Literal (string)) } , | x | { let name = x . NAME () ? ; Some (Primary :: Name (name)) } , | x | { let set = x . SET () ? ; Some (set) }] ; self . __peg (RULES) } pub fn SET (& mut self) -> Option < Primary > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Primary , 2usize > = [| x | { let _ = x . __expect ("[") ? ; let _ = x . __expect ("^") ? ; let set = { let first = match x . RANGE () { Some (value) => value , None => return x . __error ("<RANGE>") , } ; let mut body = Vec :: from ([first]) ; while let Some (data) = x . RANGE () { body . push (data) } body } ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; Some (Primary :: Exclude (set)) } , | x | { let _ = x . __expect ("[") ? ; let set = { let first = match x . RANGE () { Some (value) => value , None => return x . __error ("<RANGE>") , } ; let mut body = Vec :: from ([first]) ; while let Some (data) = x . RANGE () { body . push (data) } body } ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; Some (Primary :: Include (set)) }] ; self . __lex (RULES) } pub fn STRING (& mut self) -> Option < Vec < usize > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < usize > , 1usize > = [| x | { let _ = x . __expect ("'") ? ; let string = { let first = match x . LCH () { Some (value) => value , None => return x . __error ("<LCH>") , } ; let mut body = Vec :: from ([first]) ; while let Some (data) = x . LCH () { body . push (data) } body } ; let _ = match x . __expect ("'") { Some (value) => value , None => return x . __error ("'''") , } ; Some (string) }] ; self . __lex (RULES) } pub fn RANGE (& mut self) -> Option < (usize , usize) > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < (usize , usize) , 2usize > = [| x | { let start = x . SCH () ? ; let _ = x . __expect ("-") ? ; let end = match x . SCH () { Some (value) => value , None => return x . __error ("<SCH>") , } ; Some ((start , end)) } , | x | { let ch = x . SCH () ? ; Some ((ch , ch)) }] ; self . __lex (RULES) } pub fn NAME (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some (& (end , cache)) = self . memo . NAME . get (& (start , strict)) { self . stream . cursor = end ; return cache ; } self . stream . trim () ; let result = self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) ; let end = self . stream . cursor ; self . memo . NAME . insert ((start , strict) , (end , result)) ; result } pub fn LCH (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 38usize) => 1usize , (0usize , 40usize ..= 91usize) => 1usize , (0usize , 92usize ..= 92usize) => 2usize , (0usize , 93usize ..= 18446744073709551615usize) => 1usize , (2usize , 39usize ..= 39usize) => 1usize , (2usize , 91usize ..= 91usize) => 1usize , (2usize , 92usize ..= 92usize) => 1usize , (2usize , 93usize ..= 93usize) => 1usize , (2usize , 110usize ..= 110usize) => 1usize , (2usize , 114usize ..= 114usize) => 1usize , (2usize , 116usize ..= 116usize) => 1usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 123usize ..= 123usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (4usize , 97usize ..= 102usize) => 4usize , (4usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , true , false , false , false] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn SCH (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 91usize) => 1usize , (0usize , 92usize ..= 92usize) => 2usize , (0usize , 94usize ..= 18446744073709551615usize) => 1usize , (2usize , 39usize ..= 39usize) => 1usize , (2usize , 91usize ..= 91usize) => 1usize , (2usize , 92usize ..= 92usize) => 1usize , (2usize , 93usize ..= 93usize) => 1usize , (2usize , 110usize ..= 110usize) => 1usize , (2usize , 114usize ..= 114usize) => 1usize , (2usize , 116usize ..= 116usize) => 1usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 123usize ..= 123usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (4usize , 97usize ..= 102usize) => 4usize , (4usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , true , false , false , false] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn WS (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn COMMENT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn UNICODE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 92usize ..= 92usize) => 1usize , (1usize , 117usize ..= 117usize) => 2usize , (2usize , 123usize ..= 123usize) => 3usize , (3usize , 48usize ..= 57usize) => 3usize , (3usize , 97usize ..= 102usize) => 3usize , (3usize , 125usize ..= 125usize) => 4usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn ESCAPE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 92usize ..= 92usize) => 1usize , (1usize , 39usize ..= 39usize) => 2usize , (1usize , 91usize ..= 91usize) => 2usize , (1usize , 92usize ..= 92usize) => 2usize , (1usize , 93usize ..= 93usize) => 2usize , (1usize , 110usize ..= 110usize) => 2usize , (1usize , 114usize ..= 114usize) => 2usize , (1usize , 116usize ..= 116usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } } # [allow (unused)] impl super :: Stream { pub fn trim (& mut self) { if self . strict { return ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; loop { if self . dfa (transition , ACCEPTANCE) . is_none () { break ; } } } }