{
    use crate::ast::*;
    #[allow(unused)]
    use crate::utils::*;
}

peg grammar -> { Grammar }:
    / import=action? $ callables=(callable=callable $)* #eof {
        Grammar { import, callables }
    }
    ;

peg callable -> { Callable }:
    / decorator=decorator? prefix=PREFIX name=#NAME ty=('->' ty=#action)? #':' rule=#rule #';' {
        Callable::Rule(decorator, prefix, name, ty, rule)
    }
    / decorator=decorator? name=NAME #':' regex=#union #';' {
        Callable::Regex(decorator, name, regex)
    }
    ;

peg decorator -> { BufVec<Tag, 1> }:
    / '@' #'(' first=#tag more=(',' tag=#tag)* #')' { BufVec::new([first], more) }
    ;

peg tag -> { Tag }:
    / 'memo' { Tag::Memo }
    / 'left' { Tag::Left }
    / 'ws' { Tag::Whitespace }
    ;

peg rule -> { Rule }:
    / '/'? first=#alter more=('/' alter=#alter)* {
        Rule { first, more }
    }
    ;

peg alter -> { Alter }:
    / first=#assignment more=assignment* action=action? {
        Alter {
            assignments: BufVec::new([first], more),
            action,
        }
    }
    ;

peg assignment -> { Assignment }:
    / name=NAME '=' item=#item { Assignment::Named(name, item) }
    / lookahead=lookahead { Assignment::Lookahead(lookahead) }
    / item=item { Assignment::Anonymous(item) }
    / '$' { Assignment::Clean }
    ;

peg lookahead -> { Lookahead }:
    / '&' atom=#atom { Lookahead::Positive(atom) }
    / '!' atom=#atom { Lookahead::Negative(atom) }
    ;

peg item -> { Item }:
    / atom=atom '?' { Item::Optional(atom) }
    / atom=atom '*' { Item::Repetition(atom) }
    / eager='#'? atom=atom { Item::Name(eager.is_some(), atom) }
    ;

peg atom -> { Atom }:
    / '(' rule=#rule #')' { Atom::Nested(rule) }
    / expect=EXPECT { Atom::Expect(expect) }
    / name=NAME { Atom::Name(name) }
    ;

peg union -> { Regex }:
    / lhs=union '|' rhs=#concat { Regex::Union(lhs.into(), rhs.into()) }
    / concat=concat { concat }
    ;

peg concat -> { Regex }:
    / lhs=concat rhs=repeat { Regex::Concat(lhs.into(), rhs.into()) }
    / repeat=repeat { repeat }
    ;

peg repeat -> { Regex }:
    / inner=repeat '+' { Regex::OnceOrMore(inner.into()) }
    / inner=repeat '*' { Regex::ZeroOrMore(inner.into()) }
    / primary=primary { Regex::Primary(primary) }
    ;

peg primary -> { Primary }:
    / '(' regex=#union #')' { Primary::Parentheses(regex.into()) }
    / string=STRING { Primary::Literal(string) }
    / name=NAME { Primary::Name(name) }
    / set=SET { set }
    ;

lex PREFIX -> { Prefix }:
    / 'peg' !TAIL { Prefix::Peg }
    / 'lex' !TAIL { Prefix::Lex }
    ;

lex SET -> { Primary }:
    / '[' '^' first=#RANGE more=RANGE* #']' { Primary::Exclude(BufVec::new([first], more)) }
    / '[' first=#RANGE more=RANGE* #']' { Primary::Include(BufVec::new([first], more)) }
    ;

lex EXPECT -> { Expect }:
    / '\'' first=#SQC more=SQC* #'\'' { Expect::Once(BufVec::new([first], more)) }
    / '"' first=#DQC more=DQC* #'"' { Expect::Keyword(BufVec::new([first], more)) }
    ;

lex STRING -> { BufVec<usize, 1> }:
    / '\'' first=#SQC more=SQC* #'\'' { BufVec::new([first], more) }
    ;

lex RANGE -> { (usize, usize) }:
    / start=BC '-' end=#BC { (start, end) }
    / ch=BC { (ch, ch) }
    ;

@(memo)
NAME: [a-zA-Z_] TAIL* ;

TAIL: [a-zA-Z0-9_] ;
DQC: UNICODE | ESCAPE | [^\"\\] ;
SQC: UNICODE | ESCAPE | [^\'\\] ;
BC: UNICODE | ESCAPE | [^\]\\] ;
UNICODE: '\\' 'u' '{' [0-9a-f]* '}' ;
ESCAPE: '\\' [\'\"\[\]ntr\\] ;

@(ws)
WS: [\u{20}\n\t\r]+ ;

@(ws)
COMMENT: '//' [^\n]* ;
