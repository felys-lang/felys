{
    use crate::ast::*;
    #[allow(unused)]
    use crate::utils::*;
}

peg grammar -> { Grammar }:
    / import=ACTION? $ callables=(callable=callable $)* [#eof] {
        Grammar { import, callables }
    }
    ;

peg callable -> { Callable }:
    / deco=deco? PEG name=[NAME] ty=(ARROW ty=[ACTION])? [COLON] rule=[rule] [SEMI] {
        Callable::Peg(deco, name, ty, rule)
    }
    / deco=deco? LEX name=[NAME] ty=(ARROW ty=[ACTION])? [COLON] rule=[rule] [SEMI] {
        Callable::Lex(deco, name, ty, rule)
    }
    / deco=deco? REX name=NAME [COLON] regex=[union] [SEMI] {
        Callable::Rex(deco, name, regex)
    }
    ;

peg deco -> { BufVec<Tag, 1> }:
    / AT [LPAREN] first=[TAG] more=(COMMA tag=[TAG])* [RPAREN] { BufVec::new([first], more) }
    ;

peg rule -> { Rule }:
    / SLASH? first=[alter] more=(SLASH alter=[alter])* {
        Rule { first, more }
    }
    ;

peg alter -> { Alter }:
    / first=[assignment] more=assignment* action=ACTION? {
        Alter {
            assignments: BufVec::new([first], more),
            action,
        }
    }
    ;

peg assignment -> { Assignment }:
    / name=NAME EQ item=[item] { Assignment::Named(name, item) }
    / lookahead=lookahead { Assignment::Lookahead(lookahead) }
    / item=item { Assignment::Anonymous(item) }
    / DOLLAR { Assignment::Clean }
    ;

peg lookahead -> { Lookahead }:
    / AMPERSAND atom=[atom] { Lookahead::Positive(atom) }
    / EXCLAMATION atom=[atom] { Lookahead::Negative(atom) }
    ;

peg item -> { Item }:
    / LBRACK atom=[atom] [RBRACK] msg=MESSAGE? { Item::Eager(atom, msg) }
    / atom=atom QUESTION { Item::Optional(atom) }
    / atom=atom STAR { Item::Repetition(atom) }
    / atom=atom { Item::Name(atom) }
    ;

peg atom -> { Atom }:
    / LPAREN rule=[rule] [RPAREN] { Atom::Nested(rule) }
    / HASH name=[NAME] { Atom::External(name) }
    / name=NAME { Atom::Name(name) }
    / expect=EXPECT { Atom::Expect(expect) }
    ;

peg union -> { Regex }:
    / lhs=union PIPE rhs=[concat] { Regex::Union(lhs.into(), rhs.into()) }
    / concat=concat { concat }
    ;

peg concat -> { Regex }:
    / lhs=concat rhs=repeat { Regex::Concat(lhs.into(), rhs.into()) }
    / repeat=repeat { repeat }
    ;

peg repeat -> { Regex }:
    / inner=repeat PLUS { Regex::OnceOrMore(inner.into()) }
    / inner=repeat STAR { Regex::ZeroOrMore(inner.into()) }
    / primary=primary { Regex::Primary(primary) }
    ;

peg primary -> { Primary }:
    / LPAREN regex=[union] [RPAREN] { Primary::Parentheses(regex.into()) }
    / string=STRING { Primary::Literal(string) }
    / name=NAME { Primary::Name(name) }
    / set=SET { set }
    ;

peg SET -> { Primary }:
    / TRIM* '[' '^' first=[RANGE] more=RANGE* [']'] { Primary::Exclude(BufVec::new([first], more)) }
    / TRIM* '[' first=[RANGE] more=RANGE* [']'] { Primary::Include(BufVec::new([first], more)) }
    ;

peg EXPECT -> { Expect }:
    / TRIM* '\'' first=[SQC] more=SQC* ['\''] { Expect::Once(BufVec::new([first], more)) }
    / TRIM* '\"' first=[DQC] more=DQC* ['\"'] { Expect::Keyword(BufVec::new([first], more)) }
    ;

peg STRING -> { BufVec<usize, 1> }:
    / TRIM* '\'' first=[SQC] more=SQC* ['\''] { BufVec::new([first], more) }
    ;

peg RANGE -> { (usize, usize) }:
    / start=BC '-' end=[BC] { (start, end) }
    / ch=BC { (ch, ch) }
    ;

peg MESSAGE -> { Message }: TRIM* '(' msg=MSG* [')'] { Message(msg) } ;

peg MSG -> { Nested }:
    / '(' msg=MSG* [')'] { Nested::Inner(msg) }
    / msg=PS { Nested::Segment(msg) }
    ;

peg ACTION -> { Action }: TRIM* '{' act=ACT* ['}'] { Action(act) } ;

peg ACT -> { Nested }:
    / '{' act=ACT* ['}'] { Nested::Inner(act) }
    / act=BS { Nested::Segment(act) }
    ;

@(memo)
peg NAME -> { usize }: TRIM* ident=IDENT { ident };

peg PEG: TRIM* 'peg' !TAIL ;
peg LEX: TRIM* 'lex' !TAIL ;
peg REX: TRIM* 'rex' !TAIL ;
peg TAG -> { Tag }:
    / TRIM* 'memo' !TAIL { Tag::Memo }
    / TRIM* 'left' !TAIL { Tag::Left }
    / TRIM* 'ws' !TAIL { Tag::Whitespace }
    ;

peg EXCLAMATION: TRIM* '!' ;
peg AMPERSAND: TRIM* '&' ;
peg QUESTION: TRIM* '?' ;
peg ARROW: TRIM* '->' ;
peg DOLLAR: TRIM* '$' ;
peg LPAREN: TRIM* '(' ;
peg RPAREN: TRIM* ')' ;
peg LBRACK: TRIM* '[' ;
peg RBRACK: TRIM* ']' ;
peg SLASH: TRIM* '/' ;
peg COLON: TRIM* ':' ;
peg COMMA: TRIM* ',' ;
peg PLUS: TRIM* '+' ;
peg STAR: TRIM* '*' ;
peg PIPE: TRIM* '|' ;
peg SEMI: TRIM* ';' ;
peg HASH: TRIM* '#' ;
peg EQ: TRIM* '=' ;
peg AT: TRIM* '@' ;

rex IDENT: [a-zA-Z_] TAIL* ;
rex TAIL: [a-zA-Z0-9_] ;

rex DQC: UNICODE | ESCAPE | [^\"\\] ;
rex SQC: UNICODE | ESCAPE | [^\'\\] ;
rex BC: UNICODE | ESCAPE | [^\]\\] ;
rex UNICODE: '\\' 'u' '{' [0-9a-f]* '}' ;
rex ESCAPE: '\\' [\'\"\[\]ntr\\] ;

rex PS: [^()]+ ;
rex BS: [^{}]+ ;

rex TRIM: WS | COMMENT ;
rex WS: [\u{20}\n\t\r]+ ;
rex COMMENT: '//' [^\n]* ;
