{ use crate::ast::*; }

disjunction -> { Expr }:
    / lhs=disjunction OR rhs=conjunction! { Expr::Binary(lhs.into(), BinOp::Or, rhs.into()) }
    / conjunction=conjunction! { conjunction }
    ;

conjunction -> { Expr }:
    / lhs=conjunction AND rhs=inversion! { Expr::Binary(lhs.into(), BinOp::And, rhs.into()) }
    / inversion=inversion { inversion }
    ;

inversion -> { Expr }:
    / NOT inversion=inversion! { Expr::Unary(UnaOp::Not, inversion.into()) }
    / equality=equality { equality }
    ;

equality -> { Expr }:
    / lhs=equality EQ rhs=comparison! { Expr::Binary(lhs.into(), BinOp::Eq, rhs.into()) }
    / lhs=equality NE rhs=comparison! { Expr::Binary(lhs.into(), BinOp::Ne, rhs.into()) }
    / comparison=comparison { comparison }
    ;

comparison -> { Expr }:
    / lhs=comparison GE rhs=term! { Expr::Binary(lhs.into(), BinOp::Ge, rhs.into()) }
    / lhs=comparison LE rhs=term! { Expr::Binary(lhs.into(), BinOp::Le, rhs.into()) }
    / lhs=comparison GT rhs=term! { Expr::Binary(lhs.into(), BinOp::Gt, rhs.into()) }
    / lhs=comparison LT rhs=term! { Expr::Binary(lhs.into(), BinOp::Lt, rhs.into()) }
    / term=term { term }
    ;

term -> { Expr }:
    / lhs=term ADD rhs=factor! { Expr::Binary(lhs.into(), BinOp::Add, rhs.into()) }
    / lhs=term SUB rhs=factor! { Expr::Binary(lhs.into(), BinOp::Sub, rhs.into()) }
    / factor=factor { factor }
    ;

factor -> { Expr }:
    / lhs=factor MUL rhs=unary! { Expr::Binary(lhs.into(), BinOp::Mul, rhs.into()) }
    / lhs=factor DIV rhs=unary! { Expr::Binary(lhs.into(), BinOp::Div, rhs.into()) }
    / lhs=factor MOD rhs=unary! { Expr::Binary(lhs.into(), BinOp::Mod, rhs.into()) }
    / unary=unary { unary }
    ;

unary -> { Expr }:
    / ADD unary=unary! { Expr::Unary(UnaOp::Pos, unary.into()) }
    / SUB unary=unary! { Expr::Unary(UnaOp::Neg, unary.into()) }
    / primary=primary { primary }
    ;

primary -> { Expr }:
    / lit=lit { Expr::Lit(lit) }
    / ident=IDENT { Expr::Ident(ident) }
    ;

lit -> { Lit }:
    / lit=bool { Lit::Bool(lit) }
    ;

bool -> { Bool }:
    / TRUE { Bool::True }
    / FALSE { Bool::False }
    ;
