{
    use crate::ast::*;
    use std::rc::Rc;
}

pat -> { Pat }:
    / UNDERSCORE { Pat::Any }
    / ident=IDENT { Pat::Ident(ident) }
    / LPAREN unpack=unpack? RPAREN { Pat::Tuple(unpack.unwrap_or_default()) }
    ;

unpack -> { Vec<Pat> }:
    / unpack=COMMA.pat+ { unpack }
    ;

stmt -> { Stmt }:
    / expr=expr SEMICOLON { Stmt::Semi(expr) }
    / expr=expr { Stmt::Expr(expr) }
    / SEMICOLON { Stmt::Empty }
    ;

block -> { Block }:
    / LBRACE stmts=stmt* RBRACE! { Block(stmts) }
    ;

@(memo)
expr -> { Expr }:
    / LPAREN first=expr COMMA more=COMMA.expr+ RPAREN! { {
        let mut elements = more;
        elements.insert(0, first);
        Expr::Tuple(elements)
    } }
    / expr=disjunction { expr }
    / block=block { Expr::Block(block) }
    / LBRACK args=args? RBRACK { Expr::List(args.unwrap_or_default()) }
    / BREAK expr=expr? { Expr::Break(expr.map(Rc::new)) }
    / CONTINUE { Expr::Continue }
    / FOR pat=pat IN expr=expr block=block { Expr::For(pat, expr.into(), block) }
    / IF expr=expr block=block otherwise=otherwise? {
        Expr::If(expr.into(), block, otherwise.map(Rc::new))
    }
    / LOOP block=block! { Expr::Loop(block) }
    / RETURN expr=expr? { Expr::Return(expr.map(Rc::new)) }
    / WHILE expr=expr! block=block! { Expr::While(expr.into(), block) }
    ;

otherwise -> { Expr }:
    / ELSE expr=expr! { expr }
    ;

disjunction -> { Expr }:
    / lhs=disjunction OR rhs=conjunction! { Expr::Binary(lhs.into(), BinOp::Or, rhs.into()) }
    / conjunction=conjunction { conjunction }
    ;

conjunction -> { Expr }:
    / lhs=conjunction AND rhs=inversion! { Expr::Binary(lhs.into(), BinOp::And, rhs.into()) }
    / inversion=inversion { inversion }
    ;

inversion -> { Expr }:
    / NOT inversion=inversion! { Expr::Unary(UnaOp::Not, inversion.into()) }
    / equality=equality { equality }
    ;

equality -> { Expr }:
    / lhs=equality EQ rhs=comparison! { Expr::Binary(lhs.into(), BinOp::Eq, rhs.into()) }
    / lhs=equality NE rhs=comparison! { Expr::Binary(lhs.into(), BinOp::Ne, rhs.into()) }
    / comparison=comparison { comparison }
    ;

comparison -> { Expr }:
    / lhs=comparison GE rhs=term! { Expr::Binary(lhs.into(), BinOp::Ge, rhs.into()) }
    / lhs=comparison LE rhs=term! { Expr::Binary(lhs.into(), BinOp::Le, rhs.into()) }
    / lhs=comparison GT rhs=term! { Expr::Binary(lhs.into(), BinOp::Gt, rhs.into()) }
    / lhs=comparison LT rhs=term! { Expr::Binary(lhs.into(), BinOp::Lt, rhs.into()) }
    / term=term { term }
    ;

term -> { Expr }:
    / lhs=term ADD rhs=factor! { Expr::Binary(lhs.into(), BinOp::Add, rhs.into()) }
    / lhs=term SUB rhs=factor! { Expr::Binary(lhs.into(), BinOp::Sub, rhs.into()) }
    / factor=factor { factor }
    ;

factor -> { Expr }:
    / lhs=factor MUL rhs=unary! { Expr::Binary(lhs.into(), BinOp::Mul, rhs.into()) }
    / lhs=factor DIV rhs=unary! { Expr::Binary(lhs.into(), BinOp::Div, rhs.into()) }
    / lhs=factor MOD rhs=unary! { Expr::Binary(lhs.into(), BinOp::Mod, rhs.into()) }
    / unary=unary { unary }
    ;

unary -> { Expr }:
    / ADD unary=unary! { Expr::Unary(UnaOp::Pos, unary.into()) }
    / SUB unary=unary! { Expr::Unary(UnaOp::Neg, unary.into()) }
    / evaluation=evaluation { evaluation }
    ;

evaluation -> { Expr }:
    / evaluation=evaluation DOT field=IDENT! { Expr::Field(evaluation.into(), field) }
    / evaluation=evaluation LPAREN args=args? RPAREN! {
        Expr::Call(evaluation.into(), args.unwrap_or_default())
    }
    / primary=primary { primary }
    ;

args -> { Vec<Expr> }:
    / args=COMMA.expr+ { args }
    ;

primary -> { Expr }:
    / lit=lit { Expr::Lit(lit) }
    / ident=IDENT { Expr::Ident(ident) }
    / LPAREN expr=expr RPAREN! { Expr::Paren(expr.into()) }
    / PIPE params=params? PIPE! expr=expr! {
        Expr::Closure(params.unwrap_or_default(), expr.into())
    }
    ;

params -> { Vec<Ident> }:
    / params=COMMA.IDENT+ { params }
    ;

lit -> { Lit }:
    / lit=bool { Lit::Bool(lit) }
    ;

bool -> { Bool }:
    / TRUE { Bool::True }
    / FALSE { Bool::False }
    ;
