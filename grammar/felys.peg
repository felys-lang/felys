{
    use crate::ast::*;
    use std::rc::Rc;
}

grammar -> { Grammar }:
    / stmts=stmt* #eof { Grammar(stmts) }
    ;

pat -> { Pat }:
    / @(token)('_' !IB) { Pat::Any }
    / ident=ident { Pat::Ident(ident) }
    / '(' first=#pat #',' second=#pat more=(',' p=#pat)* ')' { {
        let mut elements = more;
        elements.insert(0, second);
        elements.insert(0, first);
        Pat::Tuple(elements)
    } }
    ;

stmt -> { Stmt }:
    / expr=expr ';' { Stmt::Semi(expr) }
    / expr=expr { Stmt::Expr(expr) }
    / ';' { Stmt::Empty }
    ;

block -> { Block }:
    / '{' stmts=stmt* #'}' { Block(stmts) }
    ;

@(memo)
expr -> { Expr }:
    / '(' first=expr ',' second=#expr ',' more=(',' e=#expr)* #')' { {
        let mut elements = more;
        elements.insert(0, second);
        elements.insert(0, first);
        Expr::Tuple(elements)
    } }
    / assign=assign { assign }
    / disjunction=disjunction { disjunction }
    / block=block { Expr::Block(block) }
    / @(token)('let' !IB) pat=#pat #'=' expr=#expr otherwise=otherwise? {
        Expr::Let(pat, expr.into(), otherwise.map(Rc::new))
    }
    / '[' args=args? #']' { Expr::List(args.unwrap_or_default()) }
    / @(token)('break' !IB) expr=expr? { Expr::Break(expr.map(Rc::new)) }
    / @(token)('continue' !IB) { Expr::Continue }
    / @(token)('for' !IB) pat=#pat @(token)(#'in' !IB) expr=#expr block=#block { Expr::For(pat, expr.into(), block) }
    / @(token)('if' !IB) expr=#expr block=#block otherwise=otherwise? {
        Expr::If(expr.into(), block, otherwise.map(Rc::new))
    }
    / @(token)('loop' !IB) block=#block { Expr::Loop(block) }
    / @(token)('return' !IB) expr=expr? { Expr::Return(expr.map(Rc::new)) }
    / @(token)('while' !IB) expr=#expr block=#block { Expr::While(expr.into(), block) }
    ;

otherwise -> { Expr }: @(token)('else' !IB) expr=#expr ;

assign -> { Expr }:
    / ident=ident '=' expr=#expr { Expr::Assign(ident, AssOp::Eq, expr.into()) }
    / ident=ident '+=' expr=#expr { Expr::Assign(ident, AssOp::AddEq, expr.into()) }
    / ident=ident '-=' expr=#expr { Expr::Assign(ident, AssOp::SubEq, expr.into()) }
    / ident=ident '*=' expr=#expr { Expr::Assign(ident, AssOp::MulEq, expr.into()) }
    / ident=ident '/=' expr=#expr { Expr::Assign(ident, AssOp::DivEq, expr.into()) }
    / ident=ident '%=' expr=#expr { Expr::Assign(ident, AssOp::ModEq, expr.into()) }
    ;

disjunction -> { Expr }:
    / lhs=disjunction @(token)('or' !IB) rhs=#conjunction { Expr::Binary(lhs.into(), BinOp::Or, rhs.into()) }
    / conjunction=conjunction { conjunction }
    ;

conjunction -> { Expr }:
    / lhs=conjunction @(token)('and' !IB) rhs=#inversion { Expr::Binary(lhs.into(), BinOp::And, rhs.into()) }
    / inversion=inversion { inversion }
    ;

inversion -> { Expr }:
    / @(token)('not' !IB) inversion=#inversion { Expr::Unary(UnaOp::Not, inversion.into()) }
    / equality=equality { equality }
    ;

equality -> { Expr }:
    / lhs=equality '==' rhs=#comparison { Expr::Binary(lhs.into(), BinOp::Eq, rhs.into()) }
    / lhs=equality '!=' rhs=#comparison { Expr::Binary(lhs.into(), BinOp::Ne, rhs.into()) }
    / comparison=comparison { comparison }
    ;

comparison -> { Expr }:
    / lhs=comparison '>=' rhs=#term { Expr::Binary(lhs.into(), BinOp::Ge, rhs.into()) }
    / lhs=comparison '<=' rhs=#term { Expr::Binary(lhs.into(), BinOp::Le, rhs.into()) }
    / lhs=comparison '>' rhs=#term { Expr::Binary(lhs.into(), BinOp::Gt, rhs.into()) }
    / lhs=comparison '<' rhs=#term { Expr::Binary(lhs.into(), BinOp::Lt, rhs.into()) }
    / term=term { term }
    ;

term -> { Expr }:
    / lhs=term '+' rhs=#factor { Expr::Binary(lhs.into(), BinOp::Add, rhs.into()) }
    / lhs=term '-' rhs=#factor { Expr::Binary(lhs.into(), BinOp::Sub, rhs.into()) }
    / factor=factor { factor }
    ;

factor -> { Expr }:
    / lhs=factor '*' rhs=#unary { Expr::Binary(lhs.into(), BinOp::Mul, rhs.into()) }
    / lhs=factor '/' rhs=#unary { Expr::Binary(lhs.into(), BinOp::Div, rhs.into()) }
    / lhs=factor '%' rhs=#unary { Expr::Binary(lhs.into(), BinOp::Mod, rhs.into()) }
    / unary=unary { unary }
    ;

unary -> { Expr }:
    / '+' unary=#unary { Expr::Unary(UnaOp::Pos, unary.into()) }
    / '-' unary=#unary { Expr::Unary(UnaOp::Neg, unary.into()) }
    / evaluation=evaluation { evaluation }
    ;

evaluation -> { Expr }:
    / evaluation=evaluation '.' field=#ident { Expr::Field(evaluation.into(), field) }
    / evaluation=evaluation '(' args=args? #')' {
        Expr::Call(evaluation.into(), args.unwrap_or_default())
    }
    / primary=primary { primary }
    ;

args -> { Vec<Expr> }:
    / first=expr more=(',' e=#expr)* { {
      let mut elements = more;
      elements.insert(0, first);
      elements
    } }
    ;

primary -> { Expr }:
    / lit=lit { Expr::Lit(lit) }
    / ident=ident { Expr::Ident(ident) }
    / '(' expr=#expr #')' { Expr::Paren(expr.into()) }
    / '|' params=params? #'|' expr=#expr {
        Expr::Closure(params.unwrap_or_default(), expr.into())
    }
    ;

params -> { Vec<Ident> }:
    / first=ident more=(',' i=#ident)* { {
      let mut elements = more;
      elements.insert(0, first);
      elements
    } }
    ;

lit -> { Lit }:
    / lit=bool { Lit::Bool(lit) }
    ;

bool -> { Bool }:
    / @(token)('true' !IB) { Bool::True }
    / @(token)('false' !IB) { Bool::False }
    ;

@(intern, memo)
IDENT: [a-zA-Z_] IB* ;

IB: [a-zA-Z0-9_] ;

@(ws) {
    WS: [\u{20}\n\t\r]+ ;
    COMMENT: '//' [^\n]* ;
}
