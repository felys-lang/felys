{
    use crate::ast::*;
    #[allow(unused)]
    use std::rc::Rc;
}

peg root -> { Root }:
    / first=[item] $ more=(item=item $)* [EOF] {
        Root(BufVec::new([first], more))
    }
    ;

peg item -> { Item }:
    / GROUP ident=[IDENT] [LPAR] params=[params] [RPAR] [SEMI] {
        Item::Group(ident, params)
    }
    / IMPL ident=[IDENT] [LBRA] first=[implementation] more=implementation* [RBRA] {
        Item::Impl(ident, BufVec::new([first], more))
    }
    / FN MAIN [LPAR] ident=[IDENT] [RPAR] block=[block] {
        Item::Main(ident, block)
    }
    / FN ident=[IDENT] [LPAR] params=params? [RPAR] block=[block] {
        Item::Fn(ident, params, block)
    }
    ;

peg implementation -> { Impl }:
    / FN ident=[IDENT] [LPAR] SELF more=(',' ident=IDENT)* ','? [RPAR] block=[block] {
        Impl::Method(ident, more, block)
    }
    / FN ident=[IDENT] [LPAR] params=params? [RPAR] block=[block] {
        Impl::Associated(ident, params, block)
    }
    ;

@(memo)
peg pat -> { Pat }:
    / UNDERSCORE { Pat::Any }
    / ident=IDENT { Pat::Ident(ident) }
    / LPAR first=pat COMMA second=pat more=(COMMA pat=pat)* COMMA? RPAR {
        Pat::Tuple(BufVec::new([first, second], more))
    }
    ;

peg block -> { Block }:
    / LBRA stmts=stmt* [RBRA] { Block(stmts) }
    ;

peg stmt -> { Stmt }:
    / assignment=assignment [SEMI]
    / expr=expr SEMI { Stmt::Semi(expr) }
    / expr=expr { Stmt::Expr(expr) }
    / SEMI { Stmt::Empty }
    ;

peg assignment -> { Stmt }:
    / pat=pat EQ expr=[expr] { Stmt::Assign(pat, AssOp::Eq, expr) }
    / pat=pat ADDEQ expr=[expr] { Stmt::Assign(pat, AssOp::AddEq, expr) }
    / pat=pat SUBEQ expr=[expr] { Stmt::Assign(pat, AssOp::SubEq, expr) }
    / pat=pat MULEQ expr=[expr] { Stmt::Assign(pat, AssOp::MulEq, expr) }
    / pat=pat DIVEQ expr=[expr] { Stmt::Assign(pat, AssOp::DivEq, expr) }
    / pat=pat MODEQ expr=[expr] { Stmt::Assign(pat, AssOp::ModEq, expr) }
    ;

@(memo)
peg expr -> { Expr }:
    / disjunction=disjunction
    / block=block { Expr::Block(block) }
    / BREAK expr=expr? { Expr::Break(expr.map(Rc::new)) }
    / CONTINUE { Expr::Continue }
    / FOR pat=[pat] [IN] expr=[expr] block=[block] { Expr::For(pat, expr.into(), block) }
    / IF expr=[expr] block=[block] otherwise=(ELSE expr=[expr])? {
        Expr::If(expr.into(), block, otherwise.map(Rc::new))
    }
    / LOOP block=[block] { Expr::Loop(block) }
    / RETURN expr=[expr] { Expr::Return(expr.into()) }
    / WHILE expr=[expr] block=[block] { Expr::While(expr.into(), block) }
    ;

peg disjunction -> { Expr }:
    / lhs=disjunction OR rhs=[conjunction] {
        Expr::Binary(lhs.into(), BinOp::Or, rhs.into())
    }
    / conjunction=conjunction
    ;

peg conjunction -> { Expr }:
    / lhs=conjunction AND rhs=[inversion] {
        Expr::Binary(lhs.into(), BinOp::And, rhs.into())
    }
    / inversion=inversion
    ;

peg inversion -> { Expr }:
    / NOT inversion=[inversion] { Expr::Unary(UnaOp::Not, inversion.into()) }
    / equality=equality
    ;

peg equality -> { Expr }:
    / lhs=equality EQ2 rhs=[comparison] { Expr::Binary(lhs.into(), BinOp::Eq, rhs.into()) }
    / lhs=equality NEQ rhs=[comparison] { Expr::Binary(lhs.into(), BinOp::Ne, rhs.into()) }
    / comparison=comparison
    ;

peg comparison -> { Expr }:
    / lhs=comparison GE rhs=[term] { Expr::Binary(lhs.into(), BinOp::Ge, rhs.into()) }
    / lhs=comparison LE rhs=[term] { Expr::Binary(lhs.into(), BinOp::Le, rhs.into()) }
    / lhs=comparison GT rhs=[term] { Expr::Binary(lhs.into(), BinOp::Gt, rhs.into()) }
    / lhs=comparison LT rhs=[term] { Expr::Binary(lhs.into(), BinOp::Lt, rhs.into()) }
    / term=term
    ;

peg term -> { Expr }:
    / lhs=term PLUS rhs=[factor] { Expr::Binary(lhs.into(), BinOp::Add, rhs.into()) }
    / lhs=term DASH rhs=[factor] { Expr::Binary(lhs.into(), BinOp::Sub, rhs.into()) }
    / factor=factor
    ;

peg factor -> { Expr }:
    / lhs=factor ASTERISK rhs=[dot] { Expr::Binary(lhs.into(), BinOp::Mul, rhs.into()) }
    / lhs=factor SLASH rhs=[dot] { Expr::Binary(lhs.into(), BinOp::Div, rhs.into()) }
    / lhs=factor PERCENT rhs=[dot] { Expr::Binary(lhs.into(), BinOp::Mod, rhs.into()) }
    / dot=dot
    ;

peg dot -> { Expr }:
    / lhs=dot AT rhs=[unary] { Expr::Binary(lhs.into(), BinOp::Dot, rhs.into()) }
    / unary=unary
    ;

peg unary -> { Expr }:
    / PLUS unary=[unary] { Expr::Unary(UnaOp::Pos, unary.into()) }
    / DASH unary=[unary] { Expr::Unary(UnaOp::Neg, unary.into()) }
    / call=call
    ;

peg call -> { Expr }:
    / call=call DOT ident=[IDENT] LPAR args=args? [RPAR] {
        Expr::Method(call.into(), ident, args)
    }
    / call=call DOT ident=[IDENT] {
        Expr::Field(call.into(), ident)
    }
    / call=call LPAR args=args? [RPAR] {
        Expr::Call(call.into(), args)
    }
    / call=call LSQB index=expr [RSQB] {
        Expr::Index(call.into(), index.into())
    }
    / primary=primary
    ;

peg args -> { BufVec<Expr, 1> }:
    / first=expr more=(COMMA expr=expr)* COMMA? { BufVec::new([first], more) }
    ;

peg primary -> { Expr }:
    / lit=lit { Expr::Lit(lit) }
    / path=path { Expr::Path(path) }
    / LPAR expr=[expr] RPAR { Expr::Paren(expr.into()) }
    / LPAR first=[expr] [COMMA] second=[expr] more=(COMMA expr=expr)* COMMA? [RPAR] {
        Expr::Tuple(BufVec::new([first, second], more))
    }
    / LSQB args=args? [RSQB] { Expr::List(args) }
    ;

peg params -> { BufVec<usize, 1> }:
    / first=IDENT more=(COMMA ident=IDENT)* COMMA? { BufVec::new([first], more) }
    ;

peg path -> { BufVec<usize, 1> }:
    / first=IDENT more=(COLON2 ident=[IDENT])* { BufVec::new([first], more) }
    ;

peg lit -> { Lit }:
    / float=FLOAT { Lit::Float(float) }
    / int=INT { Lit::Int(int) }
    / str=STR { Lit::Str(str) }
    / bool=BOOL { Lit::Bool(bool) }
    ;

peg IDENT -> { usize }: T* ident=n2i ;

peg FLOAT -> { usize }: T* float=FXX ;
peg INT -> { usize }: T* int=USIZE ;
peg STR -> { Vec<Chunk> }: T* '"' chunks=CHUNK* ['"'] ;
peg BOOL -> { Bool }:
    / T* "true" !TAIL { Bool::True }
    / T* "false" !TAIL { Bool::False }
    ;

peg FN: T* "fn" !TAIL ;
peg MAIN: T* 'main' !TAIL ;
peg GROUP: T* "group" !TAIL ;
peg IMPL: T* "impl" !TAIL ;
peg IF: T* "if" !TAIL ;
peg ELSE: T* "else" !TAIL ;
peg FOR: T* "for" !TAIL ;
peg IN: T* "in" !TAIL ;
peg WHILE: T* "while" !TAIL ;
peg LOOP: T* "loop" !TAIL ;
peg RETURN: T* "return" !TAIL ;
peg BREAK: T* "break" !TAIL ;
peg CONTINUE: T* "continue" !TAIL ;
peg SELF: T* 'self' !TAIL ;

peg OR: T* "or" !TAIL ;
peg AND: T* "and" !TAIL ;
peg NOT: T* "not" !TAIL ;
peg EQ2: T* '==' ;
peg NEQ: T* '!=' ;
peg GE: T* '>=' ;
peg LE: T* '<=' ;
peg GT: T* '>' ;
peg LT: T* '<' ;
peg PLUS: T* '+' ;
peg DASH: T* '-' ;
peg ASTERISK: T* '*' ;
peg SLASH: T* '/' ;
peg PERCENT: T* '%' ;
peg DOT: T* '.' ;
peg AT: T* '@' ;

peg EQ: T* '=' !'=' ;
peg ADDEQ: T* '+=' ;
peg SUBEQ: T* '-=' ;
peg MULEQ: T* '*=' ;
peg DIVEQ: T* '/=' ;
peg MODEQ: T* '%=' ;

peg LPAR: T* '(' ;
peg RPAR: T* ')' ;
peg LBRA: T* '{' ;
peg RBRA: T* '}' ;
peg LSQB: T* '[' ;
peg RSQB: T* ']' ;
peg COMMA: T* ',' ;
peg SEMI: T* ';' ;
peg COLON2: T* '::' ;
peg UNDERSCORE: T* '_' ;

peg EOF: T* # ;

peg CHUNK -> { Chunk }:
    / slice=SLICE { Chunk::Slice(slice) }
    / '\\u{' hex=[HEX] ['}'] { Chunk::Unicode(hex) }
    / '\\' escape=[ESCAPE] { Chunk::Escape(escape) }
    ;

rex NAME: [a-zA-Z_] TAIL* ;
@(fast)
rex TAIL: [a-zA-Z0-9_] ;

rex USIZE: '0' | [1-9][0-9]* ;
rex FXX: [1-9][0-9]* '.' [0-9]+ | '0.' [0-9]+;
rex SLICE: [^"\\]+ ;
rex HEX: [0-9a-f]+ ;
rex ESCAPE: ['"ntr\\] ;

@(fast)
rex T: WS | COMMENT ;
rex WS: [\u{20}\n\t\r]+ ;
rex COMMENT: '//' [^\n]* ;
