use std :: collections :: HashMap ; use std :: rc :: Rc ; pub struct Packrat { pub intern : Intern , pub memo : Memo , pub stream : Stream , pub snapshot : Option < (usize , & 'static str) > , } impl From < String > for Packrat { fn from (value : String) -> Self { Self { intern : Intern :: default () , memo : Memo :: default () , stream : Stream { data : value , cursor : 0 , } , snapshot : None , } } } pub (super) type Rules < T , const S : usize > = [Alternative < T > ; S] ; type Alternative < T > = fn (& mut Packrat) -> Option < T > ; impl Packrat { pub fn attempt < T > (& mut self , f : Alternative < T >) -> Option < T > { let start = self . stream . mark () ; let result = f (self) ; if result . is_none () { self . stream . jump (start) ; } result } pub fn sequential < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { rules . iter () . filter_map (| rule | self . attempt (* rule)) . next () } pub fn error < T > (& mut self , msg : & 'static str) -> Option < T > { if self . snapshot . is_some () { return None ; } let cursor = self . stream . mark () ; self . snapshot = Some ((cursor , msg)) ; None } } # [derive (Default)] pub struct Intern { data : HashMap < Rc < str > , usize > , fast : Vec < Rc < str >> , } impl Intern { pub fn id (& mut self , s : & str) -> usize { if let Some (& id) = self . data . get (s) { id } else { let key = Rc :: < str > :: from (s) ; let id = self . fast . len () ; self . fast . push (key . clone ()) ; self . data . insert (key , id) ; id } } pub fn get (& self , id : & usize) -> Option < & str > { let string = self . fast . get (* id) ? ; Some (& (* * string)) } } pub struct Stream { data : String , cursor : usize , } impl Iterator for Stream { type Item = char ; fn next (& mut self) -> Option < Self :: Item > { let remaining = & self . data [self . cursor ..] ; let ch = remaining . chars () . next () ? ; self . cursor += ch . len_utf8 () ; Some (ch) } } impl Stream { pub fn dfa < const S : usize > (& mut self , transition : fn (usize , char) -> Option < usize > , acceptance : [bool ; S]) -> Option < & str > { let start = self . mark () ; let mut end = start ; let mut s = 0usize ; while let Some (c) = self . next () { s = match transition (s , c) { Some (s) => s , None => break , } ; end = self . mark () ; } if acceptance [s] { self . jump (end) ; Some (& self . data [start .. end]) } else { self . jump (start) ; None } } pub fn peek (& mut self) -> Option < char > { self . data [self . cursor ..] . chars () . next () } pub fn mark (& self) -> usize { self . cursor } pub fn jump (& mut self , cursor : usize) { self . cursor = cursor ; } } # [allow (non_snake_case)] # [derive (Default)] pub struct Memo { }