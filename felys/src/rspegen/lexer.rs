# [allow (non_snake_case , unused)] impl super :: Packrat { pub fn NAME (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some (& (end , cache)) = self . memo . NAME . get (& (start , mode)) { self . stream . jump (end) ; return cache ; } self . stream . trim () ; let result = self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) ; let end = self . stream . mark () ; self . memo . NAME . insert ((start , mode) , (end , result)) ; result } pub fn WHITESPACE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| _ | ()) } pub fn COMMENT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| _ | ()) } } # [allow (unused)] impl super :: Stream { pub fn trim (& mut self) { if self . mode () { return ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; loop { if self . dfa (transition , ACCEPTANCE) . is_none () { break ; } } } }