# ! [doc = "Generated by rspegen"] # [allow (non_snake_case , unused)] impl super :: Packrat { pub fn IF (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 105usize ..= 105usize) => 1usize , (1usize , 102usize ..= 102usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn DIV (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn MUL (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 42usize ..= 42usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn TRUE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 116usize ..= 116usize) => 1usize , (1usize , 114usize ..= 114usize) => 2usize , (2usize , 117usize ..= 117usize) => 3usize , (3usize , 101usize ..= 101usize) => 4usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn NOT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 110usize ..= 110usize) => 1usize , (1usize , 111usize ..= 111usize) => 2usize , (2usize , 116usize ..= 116usize) => 3usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn AND (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 97usize ..= 97usize) => 1usize , (1usize , 110usize ..= 110usize) => 2usize , (2usize , 100usize ..= 100usize) => 3usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn SEMICOLON (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 59usize ..= 59usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn RETURN (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 114usize ..= 114usize) => 1usize , (1usize , 101usize ..= 101usize) => 2usize , (2usize , 116usize ..= 116usize) => 3usize , (3usize , 117usize ..= 117usize) => 4usize , (4usize , 114usize ..= 114usize) => 5usize , (5usize , 110usize ..= 110usize) => 6usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 7usize] = [false , false , false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn WS (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn RPAREN (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 41usize ..= 41usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn WHILE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 119usize ..= 119usize) => 1usize , (1usize , 104usize ..= 104usize) => 2usize , (2usize , 105usize ..= 105usize) => 3usize , (3usize , 108usize ..= 108usize) => 4usize , (4usize , 101usize ..= 101usize) => 5usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 6usize] = [false , false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn LT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 60usize ..= 60usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn LBRACE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 123usize ..= 123usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn BREAK (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 98usize ..= 98usize) => 1usize , (1usize , 114usize ..= 114usize) => 2usize , (2usize , 101usize ..= 101usize) => 3usize , (3usize , 97usize ..= 97usize) => 4usize , (4usize , 107usize ..= 107usize) => 5usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 6usize] = [false , false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn LPAREN (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 40usize ..= 40usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn RBRACE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 125usize ..= 125usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn SUB (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 45usize ..= 45usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn ADD (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 43usize ..= 43usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn IDENT (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some (& (end , cache)) = self . memo . IDENT . get (& (start , policy)) { self . stream . jump (end) ; return cache ; } self . stream . trim () ; let result = self . stream . dfa (transition , ACCEPTANCE) . and_then (| s | self . keywords . filter (s)) . map (| s | self . intern . id (s)) ; let end = self . stream . mark () ; self . memo . IDENT . insert ((start , policy) , (end , result)) ; result } pub fn COMMA (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 44usize ..= 44usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn GT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 62usize ..= 62usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn ELSE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 101usize ..= 101usize) => 1usize , (1usize , 108usize ..= 108usize) => 2usize , (2usize , 115usize ..= 115usize) => 3usize , (3usize , 101usize ..= 101usize) => 4usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn GE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 62usize ..= 62usize) => 1usize , (1usize , 61usize ..= 61usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn OR (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 111usize ..= 111usize) => 1usize , (1usize , 114usize ..= 114usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn MOD (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 37usize ..= 37usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn LOOP (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 108usize ..= 108usize) => 1usize , (1usize , 111usize ..= 111usize) => 2usize , (2usize , 111usize ..= 111usize) => 3usize , (3usize , 112usize ..= 112usize) => 4usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 5usize] = [false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn CONTINUE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 99usize ..= 99usize) => 1usize , (1usize , 111usize ..= 111usize) => 2usize , (2usize , 110usize ..= 110usize) => 3usize , (3usize , 116usize ..= 116usize) => 4usize , (4usize , 105usize ..= 105usize) => 5usize , (5usize , 110usize ..= 110usize) => 6usize , (6usize , 117usize ..= 117usize) => 7usize , (7usize , 101usize ..= 101usize) => 8usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 9usize] = [false , false , false , false , false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn FALSE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 102usize ..= 102usize) => 1usize , (1usize , 97usize ..= 97usize) => 2usize , (2usize , 108usize ..= 108usize) => 3usize , (3usize , 115usize ..= 115usize) => 4usize , (4usize , 101usize ..= 101usize) => 5usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 6usize] = [false , false , false , false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn COMMENT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn NE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 33usize ..= 33usize) => 1usize , (1usize , 61usize ..= 61usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn LE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 60usize ..= 60usize) => 1usize , (1usize , 61usize ..= 61usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn EQ (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 61usize ..= 61usize) => 1usize , (1usize , 61usize ..= 61usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } } # [allow (unused)] impl super :: Stream { pub fn trim (& mut self) { if self . policy () { return ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; loop { if self . dfa (transition , ACCEPTANCE) . is_none () { break ; } } } }