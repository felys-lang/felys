use crate :: ast ::*; # [allow (clippy :: let_unit_value)] impl super :: Packrat { pub fn disjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . disjunction () ? ; let _ = x . OR () ? ; let rhs = match x . conjunction () { Some (value) => value , None => return x . error ("conjunction") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Or , rhs . into ())) } , | x | { let conjunction = match x . conjunction () { Some (value) => value , None => return x . error ("conjunction") , } ; Some (conjunction) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . disjunction . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . disjunction . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . disjunction . insert ((start , mode) , (end , cache)) ; result } pub fn conjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . conjunction () ? ; let _ = x . AND () ? ; let rhs = match x . inversion () { Some (value) => value , None => return x . error ("inversion") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: And , rhs . into ())) } , | x | { let inversion = x . inversion () ? ; Some (inversion) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . conjunction . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . conjunction . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . conjunction . insert ((start , mode) , (end , cache)) ; result } pub fn inversion (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let _ = x . NOT () ? ; let inversion = match x . inversion () { Some (value) => value , None => return x . error ("inversion") , } ; Some (Expr :: Unary (UnaOp :: Not , inversion . into ())) } , | x | { let equality = x . equality () ? ; Some (equality) }] ; self . sequential (RULES) } pub fn equality (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . equality () ? ; let _ = x . EQ () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . error ("comparison") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Eq , rhs . into ())) } , | x | { let lhs = x . equality () ? ; let _ = x . NE () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . error ("comparison") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ne , rhs . into ())) } , | x | { let comparison = x . comparison () ? ; Some (comparison) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . equality . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . equality . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . equality . insert ((start , mode) , (end , cache)) ; result } pub fn comparison (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 5usize > = [| x | { let lhs = x . comparison () ? ; let _ = x . GE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ge , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Le , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . GT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Gt , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Lt , rhs . into ())) } , | x | { let term = x . term () ? ; Some (term) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . comparison . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . comparison . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . comparison . insert ((start , mode) , (end , cache)) ; result } pub fn term (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . term () ? ; let _ = x . ADD () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . error ("factor") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Add , rhs . into ())) } , | x | { let lhs = x . term () ? ; let _ = x . SUB () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . error ("factor") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Sub , rhs . into ())) } , | x | { let factor = x . factor () ? ; Some (factor) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . term . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . term . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . term . insert ((start , mode) , (end , cache)) ; result } pub fn factor (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 4usize > = [| x | { let lhs = x . factor () ? ; let _ = x . MUL () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mul , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . DIV () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Div , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . MOD () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mod , rhs . into ())) } , | x | { let unary = x . unary () ? ; Some (unary) }] ; let start = self . stream . mark () ; let mode = self . stream . mode () ; if let Some ((end , cache)) = self . memo . factor . get (& (start , mode)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . factor . insert ((start , mode) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . factor . insert ((start , mode) , (end , cache)) ; result } pub fn unary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let _ = x . ADD () ? ; let unary = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Unary (UnaOp :: Pos , unary . into ())) } , | x | { let _ = x . SUB () ? ; let unary = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Unary (UnaOp :: Neg , unary . into ())) } , | x | { let primary = x . primary () ? ; Some (primary) }] ; self . sequential (RULES) } pub fn primary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lit = x . lit () ? ; Some (Expr :: Lit (lit)) } , | x | { let ident = x . IDENT () ? ; Some (Expr :: Ident (ident)) }] ; self . sequential (RULES) } pub fn lit (& mut self) -> Option < Lit > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Lit , 1usize > = [| x | { let lit = x . bool () ? ; Some (Lit :: Bool (lit)) }] ; self . sequential (RULES) } pub fn bool (& mut self) -> Option < Bool > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Bool , 2usize > = [| x | { let _ = x . TRUE () ? ; Some (Bool :: True) } , | x | { let _ = x . FALSE () ? ; Some (Bool :: False) }] ; self . sequential (RULES) } }