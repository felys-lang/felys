#![doc = "Generated by rspegen"]
use crate::ast::*;
use std::rc::Rc;
#[allow(clippy::let_unit_value, non_snake_case, unused)]
impl super::Packrat {
    pub fn grammar(&mut self) -> Option<Grammar> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Grammar, 1usize> = [|x| {
            let stmts = {
                let mut body = Vec::new();
                while let Some(data) = x.stmt() {
                    body.push(data)
                }
                body
            };
            let _ = x.eof()?;
            Some(Grammar(stmts))
        }];
        self.__rule(RULES)
    }
    pub fn pat(&mut self) -> Option<Pat> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Pat, 3usize> = [
            |x| {
                let _ = x.__expect("_")?;
                Some(Pat::Any)
            },
            |x| {
                let ident = x.ident()?;
                Some(Pat::Ident(ident))
            },
            |x| {
                let _ = x.__expect("(")?;
                let first = x.pat()?;
                let _ = x.__expect(",")?;
                let more = {
                    let first = x.pat()?;
                    let mut body = Vec::from([first]);
                    while let Some(res) = x.__attempt(|x| {
                        x.__expect(",")?;
                        x.pat()
                    }) {
                        body.push(res)
                    }
                    body
                };
                let _ = x.__expect(")")?;
                Some({
                    let mut elements = more;
                    elements.insert(0, first);
                    Pat::Tuple(elements)
                })
            },
        ];
        self.__rule(RULES)
    }
    pub fn stmt(&mut self) -> Option<Stmt> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Stmt, 3usize> = [
            |x| {
                let expr = x.expr()?;
                let _ = x.__expect(";")?;
                Some(Stmt::Semi(expr))
            },
            |x| {
                let expr = x.expr()?;
                Some(Stmt::Expr(expr))
            },
            |x| {
                let _ = x.__expect(";")?;
                Some(Stmt::Empty)
            },
        ];
        self.__rule(RULES)
    }
    pub fn block(&mut self) -> Option<Block> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Block, 1usize> = [|x| {
            let _ = x.__expect("{")?;
            let stmts = {
                let mut body = Vec::new();
                while let Some(data) = x.stmt() {
                    body.push(data)
                }
                body
            };
            let _ = x.__expect("}")?;
            Some(Block(stmts))
        }];
        self.__rule(RULES)
    }
    pub fn expr(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 13usize> = [
            |x| {
                let _ = x.__expect("(")?;
                let first = x.expr()?;
                let _ = x.__expect(",")?;
                let more = {
                    let first = x.expr()?;
                    let mut body = Vec::from([first]);
                    while let Some(res) = x.__attempt(|x| {
                        x.__expect(",")?;
                        x.expr()
                    }) {
                        body.push(res)
                    }
                    body
                };
                let _ = x.__expect(")")?;
                Some({
                    let mut elements = more;
                    elements.insert(0, first);
                    Expr::Tuple(elements)
                })
            },
            |x| {
                let assign = x.assign()?;
                Some(assign)
            },
            |x| {
                let disjunction = x.disjunction()?;
                Some(disjunction)
            },
            |x| {
                let block = x.block()?;
                Some(Expr::Block(block))
            },
            |x| {
                let _ = x.__expect("let")?;
                let pat = x.pat()?;
                let _ = x.__expect("=")?;
                let expr = x.expr()?;
                let otherwise = x.otherwise();
                Some(Expr::Let(pat, expr.into(), otherwise.map(Rc::new)))
            },
            |x| {
                let _ = x.__expect("[")?;
                let args = x.args();
                let _ = x.__expect("]")?;
                Some(Expr::List(args.unwrap_or_default()))
            },
            |x| {
                let _ = x.__expect("break")?;
                let expr = x.expr();
                Some(Expr::Break(expr.map(Rc::new)))
            },
            |x| {
                let _ = x.__expect("continue")?;
                Some(Expr::Continue)
            },
            |x| {
                let _ = x.__expect("for")?;
                let pat = x.pat()?;
                let _ = x.__expect("in")?;
                let expr = x.expr()?;
                let block = x.block()?;
                Some(Expr::For(pat, expr.into(), block))
            },
            |x| {
                let _ = x.__expect("if")?;
                let expr = x.expr()?;
                let block = x.block()?;
                let otherwise = x.otherwise();
                Some(Expr::If(expr.into(), block, otherwise.map(Rc::new)))
            },
            |x| {
                let _ = x.__expect("loop")?;
                let block = x.block()?;
                Some(Expr::Loop(block))
            },
            |x| {
                let _ = x.__expect("return")?;
                let expr = x.expr();
                Some(Expr::Return(expr.map(Rc::new)))
            },
            |x| {
                let _ = x.__expect("while")?;
                let expr = x.expr()?;
                let block = x.block()?;
                Some(Expr::While(expr.into(), block))
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.expr.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let result = self.__rule(RULES);
        let end = self.stream.mark();
        let cache = result.clone();
        self.memo.expr.insert((start, policy), (end, cache));
        result
    }
    pub fn assign(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 6usize> = [
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::Eq, expr.into()))
            },
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("+=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::AddEq, expr.into()))
            },
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("-=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::SubEq, expr.into()))
            },
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("*=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::MulEq, expr.into()))
            },
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("/=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::DivEq, expr.into()))
            },
            |x| {
                let ident = x.ident()?;
                let _ = x.__expect("%=")?;
                let expr = x.expr()?;
                Some(Expr::Assign(ident, AssOp::ModEq, expr.into()))
            },
        ];
        self.__rule(RULES)
    }
    pub fn otherwise(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 1usize> = [|x| {
            let _ = x.__expect("else")?;
            let expr = x.expr()?;
            Some(expr)
        }];
        self.__rule(RULES)
    }
    pub fn disjunction(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 2usize> = [
            |x| {
                let lhs = x.disjunction()?;
                let _ = x.__expect("or")?;
                let rhs = x.conjunction()?;
                Some(Expr::Binary(lhs.into(), BinOp::Or, rhs.into()))
            },
            |x| {
                let conjunction = x.conjunction()?;
                Some(conjunction)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.disjunction.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.disjunction.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.disjunction.insert((start, policy), (end, cache));
        result
    }
    pub fn conjunction(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 2usize> = [
            |x| {
                let lhs = x.conjunction()?;
                let _ = x.__expect("and")?;
                let rhs = x.inversion()?;
                Some(Expr::Binary(lhs.into(), BinOp::And, rhs.into()))
            },
            |x| {
                let inversion = x.inversion()?;
                Some(inversion)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.conjunction.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.conjunction.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.conjunction.insert((start, policy), (end, cache));
        result
    }
    pub fn inversion(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 2usize> = [
            |x| {
                let _ = x.__expect("not")?;
                let inversion = x.inversion()?;
                Some(Expr::Unary(UnaOp::Not, inversion.into()))
            },
            |x| {
                let equality = x.equality()?;
                Some(equality)
            },
        ];
        self.__rule(RULES)
    }
    pub fn equality(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 3usize> = [
            |x| {
                let lhs = x.equality()?;
                let _ = x.__expect("==")?;
                let rhs = x.comparison()?;
                Some(Expr::Binary(lhs.into(), BinOp::Eq, rhs.into()))
            },
            |x| {
                let lhs = x.equality()?;
                let _ = x.__expect("!=")?;
                let rhs = x.comparison()?;
                Some(Expr::Binary(lhs.into(), BinOp::Ne, rhs.into()))
            },
            |x| {
                let comparison = x.comparison()?;
                Some(comparison)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.equality.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.equality.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.equality.insert((start, policy), (end, cache));
        result
    }
    pub fn comparison(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 5usize> = [
            |x| {
                let lhs = x.comparison()?;
                let _ = x.__expect(">=")?;
                let rhs = x.term()?;
                Some(Expr::Binary(lhs.into(), BinOp::Ge, rhs.into()))
            },
            |x| {
                let lhs = x.comparison()?;
                let _ = x.__expect("<=")?;
                let rhs = x.term()?;
                Some(Expr::Binary(lhs.into(), BinOp::Le, rhs.into()))
            },
            |x| {
                let lhs = x.comparison()?;
                let _ = x.__expect(">")?;
                let rhs = x.term()?;
                Some(Expr::Binary(lhs.into(), BinOp::Gt, rhs.into()))
            },
            |x| {
                let lhs = x.comparison()?;
                let _ = x.__expect("<")?;
                let rhs = x.term()?;
                Some(Expr::Binary(lhs.into(), BinOp::Lt, rhs.into()))
            },
            |x| {
                let term = x.term()?;
                Some(term)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.comparison.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.comparison.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.comparison.insert((start, policy), (end, cache));
        result
    }
    pub fn term(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 3usize> = [
            |x| {
                let lhs = x.term()?;
                let _ = x.__expect("+")?;
                let rhs = x.factor()?;
                Some(Expr::Binary(lhs.into(), BinOp::Add, rhs.into()))
            },
            |x| {
                let lhs = x.term()?;
                let _ = x.__expect("-")?;
                let rhs = x.factor()?;
                Some(Expr::Binary(lhs.into(), BinOp::Sub, rhs.into()))
            },
            |x| {
                let factor = x.factor()?;
                Some(factor)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.term.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.term.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.term.insert((start, policy), (end, cache));
        result
    }
    pub fn factor(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 4usize> = [
            |x| {
                let lhs = x.factor()?;
                let _ = x.__expect("*")?;
                let rhs = x.unary()?;
                Some(Expr::Binary(lhs.into(), BinOp::Mul, rhs.into()))
            },
            |x| {
                let lhs = x.factor()?;
                let _ = x.__expect("/")?;
                let rhs = x.unary()?;
                Some(Expr::Binary(lhs.into(), BinOp::Div, rhs.into()))
            },
            |x| {
                let lhs = x.factor()?;
                let _ = x.__expect("%")?;
                let rhs = x.unary()?;
                Some(Expr::Binary(lhs.into(), BinOp::Mod, rhs.into()))
            },
            |x| {
                let unary = x.unary()?;
                Some(unary)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.factor.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.factor.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.factor.insert((start, policy), (end, cache));
        result
    }
    pub fn unary(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 3usize> = [
            |x| {
                let _ = x.__expect("+")?;
                let unary = x.unary()?;
                Some(Expr::Unary(UnaOp::Pos, unary.into()))
            },
            |x| {
                let _ = x.__expect("-")?;
                let unary = x.unary()?;
                Some(Expr::Unary(UnaOp::Neg, unary.into()))
            },
            |x| {
                let evaluation = x.evaluation()?;
                Some(evaluation)
            },
        ];
        self.__rule(RULES)
    }
    pub fn evaluation(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 3usize> = [
            |x| {
                let evaluation = x.evaluation()?;
                let _ = x.__expect(".")?;
                let field = x.ident()?;
                Some(Expr::Field(evaluation.into(), field))
            },
            |x| {
                let evaluation = x.evaluation()?;
                let _ = x.__expect("(")?;
                let args = x.args();
                let _ = x.__expect(")")?;
                Some(Expr::Call(evaluation.into(), args.unwrap_or_default()))
            },
            |x| {
                let primary = x.primary()?;
                Some(primary)
            },
        ];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some((end, cache)) = self.memo.evaluation.get(&(start, policy)) {
            self.stream.jump(*end);
            return cache.clone();
        }
        let mut result = None;
        let mut end = start;
        loop {
            let cache = result.clone();
            self.memo.evaluation.insert((start, policy), (end, cache));
            let temp = self.__rule(RULES);
            if end < self.stream.mark() {
                result = temp;
                end = self.stream.mark();
                self.stream.jump(start);
            } else {
                self.stream.jump(end);
                break;
            }
        }
        let cache = result.clone();
        self.memo.evaluation.insert((start, policy), (end, cache));
        result
    }
    pub fn args(&mut self) -> Option<Vec<Expr>> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Vec<Expr>, 1usize> = [|x| {
            let args = {
                let first = x.expr()?;
                let mut body = Vec::from([first]);
                while let Some(res) = x.__attempt(|x| {
                    x.__expect(",")?;
                    x.expr()
                }) {
                    body.push(res)
                }
                body
            };
            Some(args)
        }];
        self.__rule(RULES)
    }
    pub fn primary(&mut self) -> Option<Expr> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Expr, 4usize> = [
            |x| {
                let lit = x.lit()?;
                Some(Expr::Lit(lit))
            },
            |x| {
                let ident = x.ident()?;
                Some(Expr::Ident(ident))
            },
            |x| {
                let _ = x.__expect("(")?;
                let expr = x.expr()?;
                let _ = x.__expect(")")?;
                Some(Expr::Paren(expr.into()))
            },
            |x| {
                let _ = x.__expect("|")?;
                let params = x.params();
                let _ = x.__expect("|")?;
                let expr = x.expr()?;
                Some(Expr::Closure(params.unwrap_or_default(), expr.into()))
            },
        ];
        self.__rule(RULES)
    }
    pub fn params(&mut self) -> Option<Vec<Ident>> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Vec<Ident>, 1usize> = [|x| {
            let params = {
                let first = x.ident()?;
                let mut body = Vec::from([first]);
                while let Some(res) = x.__attempt(|x| {
                    x.__expect(",")?;
                    x.ident()
                }) {
                    body.push(res)
                }
                body
            };
            Some(params)
        }];
        self.__rule(RULES)
    }
    pub fn lit(&mut self) -> Option<Lit> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Lit, 1usize> = [|x| {
            let lit = x.bool()?;
            Some(Lit::Bool(lit))
        }];
        self.__rule(RULES)
    }
    pub fn bool(&mut self) -> Option<Bool> {
        if self.snapshot.is_some() {
            return None;
        }
        const RULES: super::Rules<Bool, 2usize> = [
            |x| {
                let _ = x.__expect("true")?;
                Some(Bool::True)
            },
            |x| {
                let _ = x.__expect("false")?;
                Some(Bool::False)
            },
        ];
        self.__rule(RULES)
    }
    pub fn IDENT(&mut self) -> Option<usize> {
        if self.snapshot.is_some() {
            return None;
        }
        fn transition(s: usize, c: char) -> Option<usize> {
            let s = match (s, c as usize) {
                (0usize, 65usize..=90usize) => 1usize,
                (0usize, 95usize..=95usize) => 1usize,
                (0usize, 97usize..=122usize) => 1usize,
                (1usize, 48usize..=57usize) => 1usize,
                (1usize, 65usize..=90usize) => 1usize,
                (1usize, 95usize..=95usize) => 1usize,
                (1usize, 97usize..=122usize) => 1usize,
                _ => return None,
            };
            Some(s)
        }
        const ACCEPTANCE: [bool; 2usize] = [false, true];
        let start = self.stream.mark();
        let policy = self.stream.policy();
        if let Some(&(end, cache)) = self.memo.IDENT.get(&(start, policy)) {
            self.stream.jump(end);
            return cache;
        }
        self.stream.trim();
        let result = self
            .stream
            .dfa(transition, ACCEPTANCE)
            .map(|s| self.intern.id(s));
        let end = self.stream.mark();
        self.memo.IDENT.insert((start, policy), (end, result));
        result
    }
    pub fn WS(&mut self) -> Option<()> {
        if self.snapshot.is_some() {
            return None;
        }
        fn transition(s: usize, c: char) -> Option<usize> {
            let s = match (s, c as usize) {
                (0usize, 9usize..=9usize) => 1usize,
                (0usize, 10usize..=10usize) => 1usize,
                (0usize, 13usize..=13usize) => 1usize,
                (0usize, 32usize..=32usize) => 1usize,
                (1usize, 9usize..=9usize) => 1usize,
                (1usize, 10usize..=10usize) => 1usize,
                (1usize, 13usize..=13usize) => 1usize,
                (1usize, 32usize..=32usize) => 1usize,
                _ => return None,
            };
            Some(s)
        }
        const ACCEPTANCE: [bool; 2usize] = [false, true];
        self.stream.trim();
        self.stream.dfa(transition, ACCEPTANCE).and(Some(()))
    }
    pub fn COMMENT(&mut self) -> Option<()> {
        if self.snapshot.is_some() {
            return None;
        }
        fn transition(s: usize, c: char) -> Option<usize> {
            let s = match (s, c as usize) {
                (0usize, 47usize..=47usize) => 1usize,
                (1usize, 47usize..=47usize) => 2usize,
                (2usize, 0usize..=9usize) => 2usize,
                (2usize, 11usize..=18446744073709551615usize) => 2usize,
                _ => return None,
            };
            Some(s)
        }
        const ACCEPTANCE: [bool; 3usize] = [false, false, true];
        self.stream.trim();
        self.stream.dfa(transition, ACCEPTANCE).and(Some(()))
    }
}
#[allow(unused)]
impl super::Stream {
    pub fn trim(&mut self) {
        if self.policy() {
            return;
        }
        fn transition(s: usize, c: char) -> Option<usize> {
            let s = match (s, c as usize) {
                (0usize, 9usize..=9usize) => 1usize,
                (0usize, 10usize..=10usize) => 1usize,
                (0usize, 13usize..=13usize) => 1usize,
                (0usize, 32usize..=32usize) => 1usize,
                (0usize, 47usize..=47usize) => 2usize,
                (2usize, 47usize..=47usize) => 3usize,
                (3usize, 0usize..=9usize) => 3usize,
                (3usize, 11usize..=18446744073709551615usize) => 3usize,
                (1usize, 9usize..=9usize) => 1usize,
                (1usize, 10usize..=10usize) => 1usize,
                (1usize, 13usize..=13usize) => 1usize,
                (1usize, 32usize..=32usize) => 1usize,
                _ => return None,
            };
            Some(s)
        }
        const ACCEPTANCE: [bool; 4usize] = [false, true, false, true];
        loop {
            if self.dfa(transition, ACCEPTANCE).is_none() {
                break;
            }
        }
    }
}
