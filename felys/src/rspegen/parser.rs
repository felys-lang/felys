# ! [doc = "Generated by rspegen"] use crate :: ast ::*; use std :: rc :: Rc ; # [allow (clippy :: let_unit_value)] impl super :: Packrat { pub fn stmt (& mut self) -> Option < Stmt > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Stmt , 3usize > = [| x | { let expr = x . expr () ? ; let _ = x . SEMICOLON () ? ; Some (Stmt :: Semi (expr)) } , | x | { let expr = x . expr () ? ; Some (Stmt :: Expr (expr)) } , | x | { let _ = x . SEMICOLON () ? ; Some (Stmt :: Empty) }] ; self . sequential (RULES) } pub fn block (& mut self) -> Option < Block > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Block , 1usize > = [| x | { let _ = x . LBRACE () ? ; let stmts = { let mut body = Vec :: new () ; while let Some (data) = x . stmt () { body . push (data) } body } ; let _ = match x . RBRACE () { Some (value) => value , None => return x . error ("RBRACE") , } ; Some (Block (stmts)) }] ; self . sequential (RULES) } pub fn expr (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 10usize > = [| x | { let _ = x . LPAREN () ? ; let first = x . expr () ? ; let _ = x . COMMA () ? ; let more = { let first = x . expr () ? ; let mut body = Vec :: from ([first]) ; while let Some (res) = x . attempt (| x | { x . COMMA () ? ; x . expr () }) { body . push (res) } body } ; let _ = match x . RPAREN () { Some (value) => value , None => return x . error ("RPAREN") , } ; Some ({ let mut elements = more ; elements . insert (0 , first) ; Expr :: Tuple (elements) }) } , | x | { let expr = x . disjunction () ? ; Some (expr) } , | x | { let block = x . block () ? ; Some (Expr :: Block (block)) } , | x | { let _ = x . LBRACK () ? ; let args = x . args () ; let _ = x . RBRACK () ? ; Some (Expr :: List (args . unwrap_or_default ())) } , | x | { let _ = x . BREAK () ? ; let expr = x . expr () ; Some (Expr :: Break (expr . map (Rc :: new))) } , | x | { let _ = x . CONTINUE () ? ; Some (Expr :: Continue) } , | x | { let _ = x . IF () ? ; let expr = x . expr () ? ; let block = x . block () ? ; let otherwise = x . otherwise () ; Some (Expr :: If (expr . into () , block , otherwise . map (Rc :: new))) } , | x | { let _ = x . LOOP () ? ; let block = match x . block () { Some (value) => value , None => return x . error ("block") , } ; Some (Expr :: Loop (block)) } , | x | { let _ = x . RETURN () ? ; let expr = x . expr () ; Some (Expr :: Return (expr . map (Rc :: new))) } , | x | { let _ = x . WHILE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . error ("expr") , } ; let block = match x . block () { Some (value) => value , None => return x . error ("block") , } ; Some (Expr :: While (expr . into () , block)) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . expr . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let result = self . sequential (RULES) ; let end = self . stream . mark () ; let cache = result . clone () ; self . memo . expr . insert ((start , policy) , (end , cache)) ; result } pub fn otherwise (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 1usize > = [| x | { let _ = x . ELSE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . error ("expr") , } ; Some (expr) }] ; self . sequential (RULES) } pub fn disjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . disjunction () ? ; let _ = x . OR () ? ; let rhs = match x . conjunction () { Some (value) => value , None => return x . error ("conjunction") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Or , rhs . into ())) } , | x | { let conjunction = x . conjunction () ? ; Some (conjunction) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . disjunction . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . disjunction . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . disjunction . insert ((start , policy) , (end , cache)) ; result } pub fn conjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . conjunction () ? ; let _ = x . AND () ? ; let rhs = match x . inversion () { Some (value) => value , None => return x . error ("inversion") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: And , rhs . into ())) } , | x | { let inversion = x . inversion () ? ; Some (inversion) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . conjunction . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . conjunction . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . conjunction . insert ((start , policy) , (end , cache)) ; result } pub fn inversion (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let _ = x . NOT () ? ; let inversion = match x . inversion () { Some (value) => value , None => return x . error ("inversion") , } ; Some (Expr :: Unary (UnaOp :: Not , inversion . into ())) } , | x | { let equality = x . equality () ? ; Some (equality) }] ; self . sequential (RULES) } pub fn equality (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . equality () ? ; let _ = x . EQ () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . error ("comparison") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Eq , rhs . into ())) } , | x | { let lhs = x . equality () ? ; let _ = x . NE () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . error ("comparison") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ne , rhs . into ())) } , | x | { let comparison = x . comparison () ? ; Some (comparison) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . equality . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . equality . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . equality . insert ((start , policy) , (end , cache)) ; result } pub fn comparison (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 5usize > = [| x | { let lhs = x . comparison () ? ; let _ = x . GE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ge , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Le , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . GT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Gt , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . error ("term") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Lt , rhs . into ())) } , | x | { let term = x . term () ? ; Some (term) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . comparison . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . comparison . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . comparison . insert ((start , policy) , (end , cache)) ; result } pub fn term (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . term () ? ; let _ = x . ADD () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . error ("factor") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Add , rhs . into ())) } , | x | { let lhs = x . term () ? ; let _ = x . SUB () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . error ("factor") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Sub , rhs . into ())) } , | x | { let factor = x . factor () ? ; Some (factor) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . term . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . term . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . term . insert ((start , policy) , (end , cache)) ; result } pub fn factor (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 4usize > = [| x | { let lhs = x . factor () ? ; let _ = x . MUL () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mul , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . DIV () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Div , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . MOD () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mod , rhs . into ())) } , | x | { let unary = x . unary () ? ; Some (unary) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . factor . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . factor . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . factor . insert ((start , policy) , (end , cache)) ; result } pub fn unary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let _ = x . ADD () ? ; let unary = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Unary (UnaOp :: Pos , unary . into ())) } , | x | { let _ = x . SUB () ? ; let unary = match x . unary () { Some (value) => value , None => return x . error ("unary") , } ; Some (Expr :: Unary (UnaOp :: Neg , unary . into ())) } , | x | { let evaluation = x . evaluation () ? ; Some (evaluation) }] ; self . sequential (RULES) } pub fn evaluation (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let evaluation = x . evaluation () ? ; let _ = x . DOT () ? ; let field = match x . IDENT () { Some (value) => value , None => return x . error ("IDENT") , } ; Some (Expr :: Field (evaluation . into () , field)) } , | x | { let evaluation = x . evaluation () ? ; let _ = x . LPAREN () ? ; let args = x . args () ; let _ = match x . RPAREN () { Some (value) => value , None => return x . error ("RPAREN") , } ; Some (Expr :: Call (evaluation . into () , args . unwrap_or_default ())) } , | x | { let primary = x . primary () ? ; Some (primary) }] ; let start = self . stream . mark () ; let policy = self . stream . policy () ; if let Some ((end , cache)) = self . memo . evaluation . get (& (start , policy)) { self . stream . jump (* end) ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . evaluation . insert ((start , policy) , (end , cache)) ; let temp = self . sequential (RULES) ; if end < self . stream . mark () { result = temp ; end = self . stream . mark () ; self . stream . jump (start) ; } else { self . stream . jump (end) ; break ; } } let cache = result . clone () ; self . memo . evaluation . insert ((start , policy) , (end , cache)) ; result } pub fn args (& mut self) -> Option < Vec < Expr > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < Expr > , 1usize > = [| x | { let args = { let first = x . expr () ? ; let mut body = Vec :: from ([first]) ; while let Some (res) = x . attempt (| x | { x . COMMA () ? ; x . expr () }) { body . push (res) } body } ; Some (args) }] ; self . sequential (RULES) } pub fn primary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 4usize > = [| x | { let lit = x . lit () ? ; Some (Expr :: Lit (lit)) } , | x | { let ident = x . IDENT () ? ; Some (Expr :: Ident (ident)) } , | x | { let _ = x . LPAREN () ? ; let expr = x . expr () ? ; let _ = match x . RPAREN () { Some (value) => value , None => return x . error ("RPAREN") , } ; Some (Expr :: Paren (expr . into ())) } , | x | { let _ = x . PIPE () ? ; let params = x . params () ; let _ = match x . PIPE () { Some (value) => value , None => return x . error ("PIPE") , } ; let expr = match x . expr () { Some (value) => value , None => return x . error ("expr") , } ; Some (Expr :: Closure (params . unwrap_or_default () , expr . into ())) }] ; self . sequential (RULES) } pub fn params (& mut self) -> Option < Vec < Ident > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < Ident > , 1usize > = [| x | { let params = { let first = x . IDENT () ? ; let mut body = Vec :: from ([first]) ; while let Some (res) = x . attempt (| x | { x . COMMA () ? ; x . IDENT () }) { body . push (res) } body } ; Some (params) }] ; self . sequential (RULES) } pub fn lit (& mut self) -> Option < Lit > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Lit , 1usize > = [| x | { let lit = x . bool () ? ; Some (Lit :: Bool (lit)) }] ; self . sequential (RULES) } pub fn bool (& mut self) -> Option < Bool > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Bool , 2usize > = [| x | { let _ = x . TRUE () ? ; Some (Bool :: True) } , | x | { let _ = x . FALSE () ? ; Some (Bool :: False) }] ; self . sequential (RULES) } }