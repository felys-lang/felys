# ! [doc = "Generated by rspegen"] # [allow (unused)] pub struct Stream { data : String , cursor : usize , strict : bool , } impl From < String > for Stream { fn from (value : String) -> Self { Self { data : value , cursor : 0 , strict : false , } } } impl Iterator for Stream { type Item = char ; fn next (& mut self) -> Option < Self :: Item > { let remaining = & self . data [self . cursor ..] ; let ch = remaining . chars () . next () ? ; self . cursor += ch . len_utf8 () ; Some (ch) } } # [allow (unused)] impl Stream { pub fn dfa < const S : usize > (& mut self , transition : fn (usize , char) -> Option < usize > , acceptance : [bool ; S]) -> Option < & str > { let start = self . mark () ; let mut end = start ; let mut s = 0usize ; while let Some (c) = self . next () { s = match transition (s , c) { Some (s) => s , None => break , } ; end = self . mark () ; } if acceptance [s] { self . jump (end) ; Some (& self . data [start .. end]) } else { self . jump (start) ; None } } pub fn peek (& mut self) -> Option < char > { self . data [self . cursor ..] . chars () . next () } pub fn mark (& self) -> usize { self . cursor } pub fn jump (& mut self , cursor : usize) { self . cursor = cursor ; } pub fn policy (& self) -> bool { self . strict } pub fn strict (& mut self , strict : bool) { self . strict = strict ; } }