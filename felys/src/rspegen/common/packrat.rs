# ! [doc = "Generated by rspegen"] # [allow (unused)] pub struct Packrat { pub intern : super :: Intern , pub memo : super :: Memo , pub stream : super :: Stream , pub keywords : super :: Keywords , pub snapshot : Option < (usize , & 'static str) > , } impl From < String > for Packrat { fn from (value : String) -> Self { Self { intern : super :: Intern :: default () , memo : super :: Memo :: default () , stream : super :: Stream :: from (value) , keywords : super :: Keywords :: from (["or" , "and" , "not" , "true" , "false"]) , snapshot : None , } } } pub type Rules < T , const S : usize > = [fn (& mut Packrat) -> Option < T > ; S] ; # [allow (unused)] impl Packrat { pub fn attempt < T > (& mut self , f : fn (& mut Packrat) -> Option < T >) -> Option < T > { let start = self . stream . mark () ; let result = f (self) ; if result . is_none () { self . stream . jump (start) ; } result } pub fn sequential < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { rules . iter () . filter_map (| rule | self . attempt (* rule)) . next () } pub fn strict < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { self . stream . trim () ; let policy = self . stream . policy () ; self . stream . strict (true) ; let result = self . sequential (rules) ; self . stream . strict (policy) ; result } pub fn error < T > (& mut self , msg : & 'static str) -> Option < T > { if self . snapshot . is_some () { return None ; } let cursor = self . stream . mark () ; self . snapshot = Some ((cursor , msg)) ; None } }