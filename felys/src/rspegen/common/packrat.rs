# ! [doc = "Generated by rspegen"] # [allow (unused)] pub struct Packrat { pub intern : super :: Intern , pub memo : super :: Memo , pub stream : super :: Stream , pub keywords : super :: Keywords , pub snapshot : Option < (usize , & 'static str) > , } impl From < String > for Packrat { fn from (value : String) -> Self { Self { intern : super :: Intern :: default () , memo : super :: Memo :: default () , stream : super :: Stream :: from (value) , keywords : super :: Keywords :: from (["_" , "(" , "," , "," , ")" , ";" , ";" , "{" , "}" , "(" , "," , "," , ")" , "let" , "=" , "[" , "]" , "break" , "continue" , "for" , "in" , "if" , "loop" , "return" , "while" , "else" , "=" , "+=" , "-=" , "*=" , "/=" , "%=" , "or" , "and" , "not" , "==" , "!=" , ">=" , "<=" , ">" , "<" , "+" , "-" , "*" , "/" , "%" , "+" , "-" , "." , "(" , ")" , "," , "(" , ")" , "|" , "|" , "," , "true" , "false"]) , snapshot : None , } } } pub type Rules < T , const S : usize > = [fn (& mut Packrat) -> Option < T > ; S] ; # [allow (unused)] impl Packrat { pub fn __expect (& mut self , s : & 'static str) -> Option < & 'static str > { if self . snapshot . is_some () { return None ; } let start = self . stream . mark () ; self . stream . trim () ; let result = s . chars () . all (| c | self . stream . next () == Some (c)) . then_some (s) ; if result . is_none () { self . stream . jump (start) ; } result } pub fn __attempt < T > (& mut self , f : fn (& mut Packrat) -> Option < T >) -> Option < T > { let start = self . stream . mark () ; let result = f (self) ; if result . is_none () { self . stream . jump (start) ; } result } pub fn __rule < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { rules . iter () . filter_map (| rule | self . __attempt (* rule)) . next () } pub fn __token < T , const S : usize > (& mut self , rules : Rules < T , S >) -> Option < T > { self . stream . trim () ; let policy = self . stream . policy () ; self . stream . strict (true) ; let result = self . __rule (rules) ; self . stream . strict (policy) ; result } pub fn __error < T > (& mut self , msg : & 'static str) -> Option < T > { if self . snapshot . is_some () { return None ; } let cursor = self . stream . mark () ; self . snapshot = Some ((cursor , msg)) ; None } pub fn __lookahead < T > (& mut self , f : fn (& mut Packrat) -> Option < T > , behavior : bool) -> Option < () > { let start = self . stream . mark () ; let snapshot = self . snapshot ; let result = f (self) ; self . stream . jump (start) ; self . snapshot = snapshot ; if result . is_some () == behavior { Some (()) } else { None } } }