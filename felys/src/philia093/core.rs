# ! [doc = "Generated by PhiLia093"] use crate :: ast ::*; # [allow (unused)] use std :: rc :: Rc ; # [allow (clippy :: double_parens , clippy :: let_unit_value , clippy :: clone_on_copy)] # [allow (non_snake_case , unused)] impl super :: PhiLia093 { pub fn root (& mut self) -> Option < Root > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Root , 1usize > = [| x | { let first = match x . item () { Some (value) => value , None => return x . __error ("<item>") , } ; x . __memo . clean () ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let item = x . item () ? ; x . __memo . clean () ; Some ((item)) }]) { body . push (data) } body } ; let _ = match x . EOF () { Some (value) => value , None => return x . __error ("<EOF>") , } ; Some (Root (BufVec :: new ([first] , more))) }] ; self . __peg (RULES) } pub fn item (& mut self) -> Option < Item > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Item , 4usize > = [| x | { let _ = x . GROUP () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . LPAR () { Some (value) => value , None => return x . __error ("<LPAR>") , } ; let params = match x . params () { Some (value) => value , None => return x . __error ("<params>") , } ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; let _ = match x . SEMI () { Some (value) => value , None => return x . __error ("<SEMI>") , } ; Some (Item :: Group (ident , params)) } , | x | { let _ = x . IMPL () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . LBRA () { Some (value) => value , None => return x . __error ("<LBRA>") , } ; let first = match x . implementation () { Some (value) => value , None => return x . __error ("<implementation>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . implementation () { body . push (data) } body } ; let _ = match x . RBRA () { Some (value) => value , None => return x . __error ("<RBRA>") , } ; Some (Item :: Impl (ident , BufVec :: new ([first] , more))) } , | x | { let _ = x . FN () ? ; let _ = x . MAIN () ? ; let _ = match x . LPAR () { Some (value) => value , None => return x . __error ("<LPAR>") , } ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Item :: Main (ident , block)) } , | x | { let _ = x . FN () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . LPAR () { Some (value) => value , None => return x . __error ("<LPAR>") , } ; let params = x . params () ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Item :: Fn (ident , params , block)) }] ; self . __peg (RULES) } pub fn implementation (& mut self) -> Option < Impl > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Impl , 2usize > = [| x | { let _ = x . FN () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . LPAR () { Some (value) => value , None => return x . __error ("<LPAR>") , } ; let params = x . params () ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Impl :: Associated (ident , params , block)) } , | x | { let _ = x . FN () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; let _ = match x . LPAR () { Some (value) => value , None => return x . __error ("<LPAR>") , } ; let _ = x . SELF () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let ident = x . IDENT () ? ; Some ((ident)) }]) { body . push (data) } body } ; let _ = x . __expect (",") ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Impl :: Method (ident , more , block)) }] ; self . __peg (RULES) } pub fn pat (& mut self) -> Option < Pat > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Pat , 4usize > = [| x | { let ident = x . IDENT () ? ; Some (Pat :: Ident (ident)) } , | x | { let _ = x . UNDERSCORE () ? ; Some (Pat :: Any) } , | x | { let _ = x . LPAR () ? ; let first = x . pat () ? ; let _ = x . COMMA () ? ; let second = x . pat () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COMMA () ? ; let pat = x . pat () ? ; Some ((pat)) }]) { body . push (data) } body } ; let _ = x . COMMA () ; let _ = x . RPAR () ? ; Some (Pat :: Tuple (BufVec :: new ([first , second] , more))) } , | x | { let path = x . path () ? ; let _ = x . LPAR () ? ; let first = x . pat () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COMMA () ? ; let pat = x . pat () ? ; Some ((pat)) }]) { body . push (data) } body } ; let _ = x . COMMA () ; let _ = x . RPAR () ? ; Some (Pat :: Group (BufVec :: new ([first] , more))) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . pat . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let result = self . __peg (RULES) ; let end = self . __stream . cursor ; let cache = result . clone () ; self . __memo . pat . insert (start , (end , cache)) ; result } pub fn block (& mut self) -> Option < Block > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Block , 1usize > = [| x | { let _ = x . LBRA () ? ; let stmts = { let mut body = Vec :: new () ; while let Some (data) = x . stmt () { body . push (data) } body } ; let _ = match x . RBRA () { Some (value) => value , None => return x . __error ("<RBRA>") , } ; Some (Block (stmts)) }] ; self . __peg (RULES) } pub fn stmt (& mut self) -> Option < Stmt > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Stmt , 4usize > = [| x | { let assignment = x . assignment () ? ; let _ = match x . SEMI () { Some (value) => value , None => return x . __error ("<SEMI>") , } ; Some ((assignment)) } , | x | { let expr = x . expr () ? ; let _ = x . SEMI () ? ; Some (Stmt :: Semi (expr)) } , | x | { let expr = x . expr () ? ; Some (Stmt :: Expr (expr)) } , | x | { let _ = x . SEMI () ? ; Some (Stmt :: Empty) }] ; self . __peg (RULES) } pub fn assignment (& mut self) -> Option < Stmt > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Stmt , 6usize > = [| x | { let pat = x . pat () ? ; let _ = x . EQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: Eq , expr)) } , | x | { let pat = x . pat () ? ; let _ = x . ADDEQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: AddEq , expr)) } , | x | { let pat = x . pat () ? ; let _ = x . SUBEQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: SubEq , expr)) } , | x | { let pat = x . pat () ? ; let _ = x . MULEQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: MulEq , expr)) } , | x | { let pat = x . pat () ? ; let _ = x . DIVEQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: DivEq , expr)) } , | x | { let pat = x . pat () ? ; let _ = x . MODEQ () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Stmt :: Assign (pat , AssOp :: ModEq , expr)) }] ; self . __peg (RULES) } pub fn expr (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 9usize > = [| x | { let disjunction = x . disjunction () ? ; Some ((disjunction)) } , | x | { let block = x . block () ? ; Some (Expr :: Block (block)) } , | x | { let _ = x . BREAK () ? ; let expr = x . expr () ; Some (Expr :: Break (expr . map (Rc :: new))) } , | x | { let _ = x . CONTINUE () ? ; Some (Expr :: Continue) } , | x | { let _ = x . FOR () ? ; let pat = match x . pat () { Some (value) => value , None => return x . __error ("<pat>") , } ; let _ = match x . IN () { Some (value) => value , None => return x . __error ("<IN>") , } ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: For (pat , expr . into () , block)) } , | x | { let _ = x . IF () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; let otherwise = x . __peg ([| x | { let _ = x . ELSE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some ((expr)) }]) ; Some (Expr :: If (expr . into () , block , otherwise . map (Rc :: new))) } , | x | { let _ = x . LOOP () ? ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: Loop (block)) } , | x | { let _ = x . RETURN () ? ; let expr = x . expr () ; Some (Expr :: Return (expr . map (Rc :: new))) } , | x | { let _ = x . WHILE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: While (expr . into () , block)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . expr . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let result = self . __peg (RULES) ; let end = self . __stream . cursor ; let cache = result . clone () ; self . __memo . expr . insert (start , (end , cache)) ; result } pub fn disjunction (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 2usize > = [| x | { let lhs = x . disjunction () ? ; let _ = x . OR () ? ; let rhs = match x . conjunction () { Some (value) => value , None => return x . __error ("<conjunction>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Or , rhs . into ())) } , | x | { let conjunction = x . conjunction () ? ; Some ((conjunction)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . disjunction . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . disjunction . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . disjunction . insert (start , (end , cache)) ; result } pub fn conjunction (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 2usize > = [| x | { let lhs = x . conjunction () ? ; let _ = x . AND () ? ; let rhs = match x . inversion () { Some (value) => value , None => return x . __error ("<inversion>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: And , rhs . into ())) } , | x | { let inversion = x . inversion () ? ; Some ((inversion)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . conjunction . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . conjunction . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . conjunction . insert (start , (end , cache)) ; result } pub fn inversion (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 2usize > = [| x | { let _ = x . NOT () ? ; let inversion = match x . inversion () { Some (value) => value , None => return x . __error ("<inversion>") , } ; Some (Expr :: Unary (UnaOp :: Not , inversion . into ())) } , | x | { let equality = x . equality () ? ; Some ((equality)) }] ; self . __peg (RULES) } pub fn equality (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 3usize > = [| x | { let lhs = x . equality () ? ; let _ = x . EQ2 () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . __error ("<comparison>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Eq , rhs . into ())) } , | x | { let lhs = x . equality () ? ; let _ = x . NEQ () ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . __error ("<comparison>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ne , rhs . into ())) } , | x | { let comparison = x . comparison () ? ; Some ((comparison)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . equality . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . equality . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . equality . insert (start , (end , cache)) ; result } pub fn comparison (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 5usize > = [| x | { let lhs = x . comparison () ? ; let _ = x . GE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ge , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LE () ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Le , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . GT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Gt , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . LT () ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Lt , rhs . into ())) } , | x | { let term = x . term () ? ; Some ((term)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . comparison . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . comparison . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . comparison . insert (start , (end , cache)) ; result } pub fn term (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 3usize > = [| x | { let lhs = x . term () ? ; let _ = x . PLUS () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . __error ("<factor>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Add , rhs . into ())) } , | x | { let lhs = x . term () ? ; let _ = x . DASH () ? ; let rhs = match x . factor () { Some (value) => value , None => return x . __error ("<factor>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Sub , rhs . into ())) } , | x | { let factor = x . factor () ? ; Some ((factor)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . term . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . term . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . term . insert (start , (end , cache)) ; result } pub fn factor (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 4usize > = [| x | { let lhs = x . factor () ? ; let _ = x . ASTERISK () ? ; let rhs = match x . dot () { Some (value) => value , None => return x . __error ("<dot>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mul , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . SLASH () ? ; let rhs = match x . dot () { Some (value) => value , None => return x . __error ("<dot>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Div , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . PERCENT () ? ; let rhs = match x . dot () { Some (value) => value , None => return x . __error ("<dot>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mod , rhs . into ())) } , | x | { let dot = x . dot () ? ; Some ((dot)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . factor . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . factor . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . factor . insert (start , (end , cache)) ; result } pub fn dot (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 2usize > = [| x | { let lhs = x . dot () ? ; let _ = x . AT () ? ; let rhs = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Dot , rhs . into ())) } , | x | { let unary = x . unary () ? ; Some ((unary)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . dot . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . dot . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . dot . insert (start , (end , cache)) ; result } pub fn unary (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 3usize > = [| x | { let _ = x . PLUS () ? ; let unary = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Unary (UnaOp :: Pos , unary . into ())) } , | x | { let _ = x . DASH () ? ; let unary = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Unary (UnaOp :: Neg , unary . into ())) } , | x | { let call = x . call () ? ; Some ((call)) }] ; self . __peg (RULES) } pub fn call (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 3usize > = [| x | { let call = x . call () ? ; let _ = x . LPAR () ? ; let args = x . args () ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; Some (Expr :: Call (call . into () , args)) } , | x | { let call = x . call () ? ; let _ = x . DOT () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; Some (Expr :: Field (call . into () , ident)) } , | x | { let primary = x . primary () ? ; Some ((primary)) }] ; let start = self . __stream . cursor ; if let Some ((end , cache)) = self . __memo . call . get (& start) { self . __stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . __memo . call . insert (start , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . __stream . cursor { result = temp ; end = self . __stream . cursor ; self . __stream . cursor = start ; } else { self . __stream . cursor = end ; break ; } } let cache = result . clone () ; self . __memo . call . insert (start , (end , cache)) ; result } pub fn args (& mut self) -> Option < BufVec < Expr , 1 > > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < BufVec < Expr , 1 > , 1usize > = [| x | { let first = x . expr () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COMMA () ? ; let expr = x . expr () ? ; Some ((expr)) }]) { body . push (data) } body } ; let _ = x . COMMA () ; Some (BufVec :: new ([first] , more)) }] ; self . __peg (RULES) } pub fn primary (& mut self) -> Option < Expr > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Expr , 6usize > = [| x | { let lit = x . lit () ? ; Some (Expr :: Lit (lit)) } , | x | { let path = x . path () ? ; Some (Expr :: Path (path)) } , | x | { let _ = x . LPAR () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let _ = x . RPAR () ? ; Some (Expr :: Paren (expr . into ())) } , | x | { let _ = x . LPAR () ? ; let first = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let _ = match x . COMMA () { Some (value) => value , None => return x . __error ("<COMMA>") , } ; let second = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COMMA () ? ; let expr = x . expr () ? ; Some ((expr)) }]) { body . push (data) } body } ; let _ = x . COMMA () ; let _ = match x . RPAR () { Some (value) => value , None => return x . __error ("<RPAR>") , } ; Some (Expr :: Tuple (BufVec :: new ([first , second] , more))) } , | x | { let _ = x . LSQB () ? ; let args = x . args () ; let _ = match x . RSQB () { Some (value) => value , None => return x . __error ("<RSQB>") , } ; Some (Expr :: List (args)) } , | x | { let _ = x . PIPE () ? ; let params = x . params () ; let _ = match x . PIPE () { Some (value) => value , None => return x . __error ("<PIPE>") , } ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Lambda (params , expr . into ())) }] ; self . __peg (RULES) } pub fn params (& mut self) -> Option < BufVec < Ident , 1 > > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < BufVec < Ident , 1 > , 1usize > = [| x | { let first = x . IDENT () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COMMA () ? ; let ident = x . IDENT () ? ; Some ((ident)) }]) { body . push (data) } body } ; let _ = x . COMMA () ; Some (BufVec :: new ([first] , more)) }] ; self . __peg (RULES) } pub fn path (& mut self) -> Option < Path > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Path , 2usize > = [| x | { let _ = x . STD () ? ; let _ = match x . COLON2 () { Some (value) => value , None => return x . __error ("<COLON2>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COLON2 () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; Some ((ident)) }]) { body . push (data) } body } ; Some (Path :: Std (more)) } , | x | { let first = x . IDENT () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . COLON2 () ? ; let ident = match x . IDENT () { Some (value) => value , None => return x . __error ("<IDENT>") , } ; Some ((ident)) }]) { body . push (data) } body } ; Some (Path :: Default (BufVec :: new ([first] , more))) }] ; self . __peg (RULES) } pub fn lit (& mut self) -> Option < Lit > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Lit , 4usize > = [| x | { let float = x . FLOAT () ? ; Some (Lit :: Float (float)) } , | x | { let int = x . INT () ? ; Some (Lit :: Int (int)) } , | x | { let str = x . STR () ? ; Some (Lit :: Str (str)) } , | x | { let bool = x . BOOL () ? ; Some (Lit :: Bool (bool)) }] ; self . __peg (RULES) } pub fn IDENT (& mut self) -> Option < Ident > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Ident , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let ident = x . n2i () ? ; Some ((ident)) }] ; self . __peg (RULES) } pub fn FLOAT (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < usize , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let float = x . FXX () ? ; Some ((float)) }] ; self . __peg (RULES) } pub fn INT (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < usize , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let int = x . USIZE () ? ; Some ((int)) }] ; self . __peg (RULES) } pub fn STR (& mut self) -> Option < Vec < Chunk > > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Vec < Chunk > , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("\"") ? ; let chunks = { let mut body = Vec :: new () ; while let Some (data) = x . CHUNK () { body . push (data) } body } ; let _ = match x . __expect ("\"") { Some (value) => value , None => return x . __error ("'\"'") , } ; Some ((chunks)) }] ; self . __peg (RULES) } pub fn BOOL (& mut self) -> Option < Bool > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Bool , 2usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("true") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Bool :: True) } , | x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("false") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Bool :: False) }] ; self . __peg (RULES) } pub fn FN (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("fn") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn MAIN (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("main") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn GROUP (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("group") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn IMPL (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("impl") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn IF (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("if") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn ELSE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("else") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn FOR (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("for") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn IN (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("in") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn WHILE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("while") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn LOOP (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("loop") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn RETURN (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("return") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn BREAK (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("break") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn CONTINUE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("continue") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn SELF (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("self") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn STD (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("std") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn OR (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("or") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn AND (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("and") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn NOT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("not") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn EQ2 (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("==") ? ; Some (()) }] ; self . __peg (RULES) } pub fn NEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("!=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn GE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (">=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn LE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("<=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn GT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (">") ? ; Some (()) }] ; self . __peg (RULES) } pub fn LT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("<") ? ; Some (()) }] ; self . __peg (RULES) } pub fn PLUS (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("+") ? ; Some (()) }] ; self . __peg (RULES) } pub fn DASH (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("-") ? ; Some (()) }] ; self . __peg (RULES) } pub fn ASTERISK (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("*") ? ; Some (()) }] ; self . __peg (RULES) } pub fn SLASH (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("/") ? ; Some (()) }] ; self . __peg (RULES) } pub fn PERCENT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("%") ? ; Some (()) }] ; self . __peg (RULES) } pub fn AT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("@") ? ; Some (()) }] ; self . __peg (RULES) } pub fn EQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("=") ? ; let _ = x . __lookahead (| x | x . __expect ("=") , false) ? ; Some (()) }] ; self . __peg (RULES) } pub fn ADDEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("+=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn SUBEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("-=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn MULEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("*=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn DIVEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("/=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn MODEQ (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("%=") ? ; Some (()) }] ; self . __peg (RULES) } pub fn LPAR (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("(") ? ; Some (()) }] ; self . __peg (RULES) } pub fn RPAR (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (")") ? ; Some (()) }] ; self . __peg (RULES) } pub fn LBRA (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("{") ? ; Some (()) }] ; self . __peg (RULES) } pub fn RBRA (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("}") ? ; Some (()) }] ; self . __peg (RULES) } pub fn LSQB (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("[") ? ; Some (()) }] ; self . __peg (RULES) } pub fn RSQB (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("]") ? ; Some (()) }] ; self . __peg (RULES) } pub fn COMMA (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (",") ? ; Some (()) }] ; self . __peg (RULES) } pub fn DOT (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (".") ? ; Some (()) }] ; self . __peg (RULES) } pub fn SEMI (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect (";") ? ; Some (()) }] ; self . __peg (RULES) } pub fn PIPE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("|") ? ; Some (()) }] ; self . __peg (RULES) } pub fn COLON2 (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("::") ? ; Some (()) }] ; self . __peg (RULES) } pub fn UNDERSCORE (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; let _ = x . __expect ("_") ? ; Some (()) }] ; self . __peg (RULES) } pub fn EOF (& mut self) -> Option < () > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < () , 1usize > = [| x | { let _ = { let mut body = Vec :: new () ; while let Some (data) = x . T () { body . push (data) } body } ; x . __eof () ; Some (()) }] ; self . __peg (RULES) } pub fn CHUNK (& mut self) -> Option < Chunk > { if self . __snapshot . is_some () { return None ; } const RULES : super :: R < Chunk , 3usize > = [| x | { let slice = x . SLICE () ? ; Some (Chunk :: Slice (slice)) } , | x | { let _ = x . __expect ("\\u{") ? ; let hex = match x . HEX () { Some (value) => value , None => return x . __error ("<HEX>") , } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Chunk :: Unicode (hex)) } , | x | { let _ = x . __expect ("\\") ? ; let escape = match x . ESCAPE () { Some (value) => value , None => return x . __error ("<ESCAPE>") , } ; Some (Chunk :: Escape (escape)) }] ; self . __peg (RULES) } pub fn NAME (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn TAIL (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 57usize) => 1usize , (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn USIZE (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 48usize) => 1usize , (0usize , 49usize ..= 57usize) => 2usize , (2usize , 48usize ..= 57usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , true , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn FXX (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 48usize) => 1usize , (0usize , 49usize ..= 57usize) => 2usize , (2usize , 46usize ..= 46usize) => 3usize , (2usize , 48usize ..= 57usize) => 2usize , (3usize , 48usize ..= 57usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (1usize , 46usize ..= 46usize) => 5usize , (5usize , 48usize ..= 57usize) => 6usize , (6usize , 48usize ..= 57usize) => 6usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 7usize] = [false , false , false , false , true , false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn SLICE (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 33usize) => 1usize , (0usize , 35usize ..= 91usize) => 1usize , (0usize , 93usize ..= 18446744073709551615usize) => 1usize , (1usize , 0usize ..= 33usize) => 1usize , (1usize , 35usize ..= 91usize) => 1usize , (1usize , 93usize ..= 18446744073709551615usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn HEX (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 57usize) => 1usize , (0usize , 97usize ..= 102usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 97usize ..= 102usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn ESCAPE (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 34usize ..= 34usize) => 1usize , (0usize , 39usize ..= 39usize) => 1usize , (0usize , 92usize ..= 92usize) => 1usize , (0usize , 110usize ..= 110usize) => 1usize , (0usize , 114usize ..= 114usize) => 1usize , (0usize , 116usize ..= 116usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn T (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn WS (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } pub fn COMMENT (& mut self) -> Option < usize > { if self . __snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . __stream . dfa (transition , ACCEPTANCE) . map (| s | self . __intern . id (s)) } }