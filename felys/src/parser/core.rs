# ! [doc = "Generated by rspegen"] use crate :: ast ::*; # [allow (unused)] use std :: rc :: Rc ; # [allow (clippy :: double_parens , clippy :: let_unit_value)] # [allow (non_snake_case , unused)] impl super :: Packrat { pub fn grammar (& mut self) -> Option < Grammar > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Grammar , 1usize > = [| x | { let stmts = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let stmt = x . stmt () ? ; x . memo . clean () ; Some ((stmt)) }]) { body . push (data) } body } ; let _ = match x . eof () { Some (value) => value , None => return x . __error ("<eof>") , } ; Some (Grammar (stmts)) }] ; self . __peg (RULES) } pub fn pat (& mut self) -> Option < Pat > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Pat , 4usize > = [| x | { let _ = x . UNDERSCORE () ? ; Some (Pat :: Any) } , | x | { let ident = x . ident () ? ; Some (Pat :: Ident (ident)) } , | x | { let lit = x . lit () ? ; Some (Pat :: Lit (lit)) } , | x | { let _ = x . __expect ("(") ? ; let first = x . pat () ? ; let _ = x . __expect (",") ? ; let second = match x . pat () { Some (value) => value , None => return x . __error ("<pat>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let pat = match x . pat () { Some (value) => value , None => return x . __error ("<pat>") , } ; Some ((pat)) }]) { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some ({ let mut elements = more ; elements . insert (0 , second) ; elements . insert (0 , first) ; Pat :: Tuple (elements) }) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . pat . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let result = self . __peg (RULES) ; let end = self . stream . cursor ; let cache = result . clone () ; self . memo . pat . insert ((start , strict) , (end , cache)) ; result } pub fn stmt (& mut self) -> Option < Stmt > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Stmt , 3usize > = [| x | { let expr = x . expr () ? ; let _ = x . __expect (";") ? ; Some (Stmt :: Semi (expr)) } , | x | { let expr = x . expr () ? ; Some (Stmt :: Expr (expr)) } , | x | { let _ = x . __expect (";") ? ; Some (Stmt :: Empty) }] ; self . __peg (RULES) } pub fn block (& mut self) -> Option < Block > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Block , 1usize > = [| x | { let _ = x . __expect ("{") ? ; let stmts = { let mut body = Vec :: new () ; while let Some (data) = x . stmt () { body . push (data) } body } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Block (stmts)) }] ; self . __peg (RULES) } pub fn expr (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 10usize > = [| x | { let assignment = x . assignment () ? ; Some ((assignment)) } , | x | { let disjunction = x . disjunction () ? ; Some ((disjunction)) } , | x | { let block = x . block () ? ; Some (Expr :: Block (block)) } , | x | { let _ = x . BREAK () ? ; let expr = x . expr () ; Some (Expr :: Break (expr . map (Rc :: new))) } , | x | { let _ = x . CONTINUE () ? ; Some (Expr :: Continue) } , | x | { let _ = x . FOR () ? ; let pat = match x . pat () { Some (value) => value , None => return x . __error ("<pat>") , } ; let _ = x . IN () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: For (pat , expr . into () , block)) } , | x | { let _ = x . IF () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; let otherwise = x . __peg ([| x | { let _ = x . ELSE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some ((expr)) }]) ; Some (Expr :: If (expr . into () , block , otherwise . map (Rc :: new))) } , | x | { let _ = x . LOOP () ? ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: Loop (block)) } , | x | { let _ = x . RETURN () ? ; let expr = x . expr () ; Some (Expr :: Return (expr . map (Rc :: new))) } , | x | { let _ = x . WHILE () ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let block = match x . block () { Some (value) => value , None => return x . __error ("<block>") , } ; Some (Expr :: While (expr . into () , block)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . expr . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let result = self . __peg (RULES) ; let end = self . stream . cursor ; let cache = result . clone () ; self . memo . expr . insert ((start , strict) , (end , cache)) ; result } pub fn assignment (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 6usize > = [| x | { let pat = x . pat () ? ; let _ = x . __expect ("=") ? ; let _ = x . __lookahead (| x | x . __expect ("=") , false) ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: Eq , expr . into ())) } , | x | { let pat = x . pat () ? ; let _ = x . __expect ("+=") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: AddEq , expr . into ())) } , | x | { let pat = x . pat () ? ; let _ = x . __expect ("-=") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: SubEq , expr . into ())) } , | x | { let pat = x . pat () ? ; let _ = x . __expect ("*=") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: MulEq , expr . into ())) } , | x | { let pat = x . pat () ? ; let _ = x . __expect ("/=") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: DivEq , expr . into ())) } , | x | { let pat = x . pat () ? ; let _ = x . __expect ("%=") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Assign (pat , AssOp :: ModEq , expr . into ())) }] ; self . __peg (RULES) } pub fn disjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . disjunction () ? ; let _ = x . OR () ? ; let rhs = match x . conjunction () { Some (value) => value , None => return x . __error ("<conjunction>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Or , rhs . into ())) } , | x | { let conjunction = x . conjunction () ? ; Some ((conjunction)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . disjunction . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . disjunction . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . disjunction . insert ((start , strict) , (end , cache)) ; result } pub fn conjunction (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let lhs = x . conjunction () ? ; let _ = x . AND () ? ; let rhs = match x . inversion () { Some (value) => value , None => return x . __error ("<inversion>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: And , rhs . into ())) } , | x | { let inversion = x . inversion () ? ; Some ((inversion)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . conjunction . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . conjunction . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . conjunction . insert ((start , strict) , (end , cache)) ; result } pub fn inversion (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let _ = x . NOT () ? ; let inversion = match x . inversion () { Some (value) => value , None => return x . __error ("<inversion>") , } ; Some (Expr :: Unary (UnaOp :: Not , inversion . into ())) } , | x | { let equality = x . equality () ? ; Some ((equality)) }] ; self . __peg (RULES) } pub fn equality (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . equality () ? ; let _ = x . __expect ("==") ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . __error ("<comparison>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Eq , rhs . into ())) } , | x | { let lhs = x . equality () ? ; let _ = x . __expect ("!=") ? ; let rhs = match x . comparison () { Some (value) => value , None => return x . __error ("<comparison>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ne , rhs . into ())) } , | x | { let comparison = x . comparison () ? ; Some ((comparison)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . equality . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . equality . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . equality . insert ((start , strict) , (end , cache)) ; result } pub fn comparison (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 5usize > = [| x | { let lhs = x . comparison () ? ; let _ = x . __expect (">=") ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Ge , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . __expect ("<=") ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Le , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . __expect (">") ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Gt , rhs . into ())) } , | x | { let lhs = x . comparison () ? ; let _ = x . __expect ("<") ? ; let rhs = match x . term () { Some (value) => value , None => return x . __error ("<term>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Lt , rhs . into ())) } , | x | { let term = x . term () ? ; Some ((term)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . comparison . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . comparison . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . comparison . insert ((start , strict) , (end , cache)) ; result } pub fn term (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let lhs = x . term () ? ; let _ = x . __expect ("+") ? ; let rhs = match x . factor () { Some (value) => value , None => return x . __error ("<factor>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Add , rhs . into ())) } , | x | { let lhs = x . term () ? ; let _ = x . __expect ("-") ? ; let rhs = match x . factor () { Some (value) => value , None => return x . __error ("<factor>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Sub , rhs . into ())) } , | x | { let factor = x . factor () ? ; Some ((factor)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . term . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . term . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . term . insert ((start , strict) , (end , cache)) ; result } pub fn factor (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 4usize > = [| x | { let lhs = x . factor () ? ; let _ = x . __expect ("*") ? ; let rhs = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mul , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . __expect ("/") ? ; let rhs = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Div , rhs . into ())) } , | x | { let lhs = x . factor () ? ; let _ = x . __expect ("%") ? ; let rhs = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Binary (lhs . into () , BinOp :: Mod , rhs . into ())) } , | x | { let unary = x . unary () ? ; Some ((unary)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . factor . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . factor . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . factor . insert ((start , strict) , (end , cache)) ; result } pub fn unary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 3usize > = [| x | { let _ = x . __expect ("+") ? ; let unary = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Unary (UnaOp :: Pos , unary . into ())) } , | x | { let _ = x . __expect ("-") ? ; let unary = match x . unary () { Some (value) => value , None => return x . __error ("<unary>") , } ; Some (Expr :: Unary (UnaOp :: Neg , unary . into ())) } , | x | { let call = x . call () ? ; Some ((call)) }] ; self . __peg (RULES) } pub fn call (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 2usize > = [| x | { let call = x . call () ? ; let _ = x . __expect ("(") ? ; let args = x . args () ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some (Expr :: Call (call . into () , args . unwrap_or_default ())) } , | x | { let primary = x . primary () ? ; Some ((primary)) }] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some ((end , cache)) = self . memo . call . get (& (start , strict)) { self . stream . cursor = end . to_owned () ; return cache . clone () ; } let mut result = None ; let mut end = start ; loop { let cache = result . clone () ; self . memo . call . insert ((start , strict) , (end , cache)) ; let temp = self . __peg (RULES) ; if end < self . stream . cursor { result = temp ; end = self . stream . cursor ; self . stream . cursor = start ; } else { self . stream . cursor = end ; break ; } } let cache = result . clone () ; self . memo . call . insert ((start , strict) , (end , cache)) ; result } pub fn args (& mut self) -> Option < Vec < Expr > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < Expr > , 1usize > = [| x | { let first = x . expr () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some ((expr)) }]) { body . push (data) } body } ; Some ({ let mut elements = more ; elements . insert (0 , first) ; elements }) }] ; self . __peg (RULES) } pub fn primary (& mut self) -> Option < Expr > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Expr , 6usize > = [| x | { let lit = x . lit () ? ; Some (Expr :: Lit (lit)) } , | x | { let ident = x . ident () ? ; Some (Expr :: Ident (ident)) } , | x | { let _ = x . __expect ("(") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let _ = x . __expect (")") ? ; Some (Expr :: Paren (expr . into ())) } , | x | { let _ = x . __expect ("(") ? ; let first = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let _ = match x . __expect (",") { Some (value) => value , None => return x . __error ("','") , } ; let second = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some ((expr)) }]) { body . push (data) } body } ; let _ = match x . __expect (")") { Some (value) => value , None => return x . __error ("')'") , } ; Some ({ let mut elements = more ; elements . insert (0 , second) ; elements . insert (0 , first) ; Expr :: Tuple (elements) }) } , | x | { let _ = x . __expect ("[") ? ; let args = x . args () ; let _ = match x . __expect ("]") { Some (value) => value , None => return x . __error ("']'") , } ; Some (Expr :: List (args . unwrap_or_default ())) } , | x | { let _ = x . __expect ("|") ? ; let params = x . params () ; let _ = match x . __expect ("|") { Some (value) => value , None => return x . __error ("'|'") , } ; let expr = match x . expr () { Some (value) => value , None => return x . __error ("<expr>") , } ; Some (Expr :: Closure (params . unwrap_or_default () , expr . into ())) }] ; self . __peg (RULES) } pub fn params (& mut self) -> Option < Vec < Ident > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < Ident > , 1usize > = [| x | { let first = x . ident () ? ; let more = { let mut body = Vec :: new () ; while let Some (data) = x . __peg ([| x | { let _ = x . __expect (",") ? ; let ident = match x . ident () { Some (value) => value , None => return x . __error ("<ident>") , } ; Some ((ident)) }]) { body . push (data) } body } ; Some ({ let mut elements = more ; elements . insert (0 , first) ; elements }) }] ; self . __peg (RULES) } pub fn lit (& mut self) -> Option < Lit > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Lit , 4usize > = [| x | { let float = x . FLOAT () ? ; Some (Lit :: Float (float)) } , | x | { let int = x . INT () ? ; Some (Lit :: Int (int)) } , | x | { let str = x . STR () ? ; Some (Lit :: Str (str)) } , | x | { let bool = x . BOOL () ? ; Some (Lit :: Bool (bool)) }] ; self . __peg (RULES) } pub fn STR (& mut self) -> Option < Vec < Chunk > > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Vec < Chunk > , 1usize > = [| x | { let _ = x . __expect ("\"") ? ; let chunks = { let mut body = Vec :: new () ; while let Some (data) = x . CHUNK () { body . push (data) } body } ; let _ = match x . __expect ("\"") { Some (value) => value , None => return x . __error ("'\"'") , } ; Some ((chunks)) }] ; self . __lex (RULES) } pub fn CHUNK (& mut self) -> Option < Chunk > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Chunk , 3usize > = [| x | { let slice = x . SLICE () ? ; Some (Chunk :: Slice (slice)) } , | x | { let _ = x . __expect ("\\u{") ? ; let hex = match x . HEX () { Some (value) => value , None => return x . __error ("<HEX>") , } ; let _ = match x . __expect ("}") { Some (value) => value , None => return x . __error ("'}'") , } ; Some (Chunk :: Unicode (hex)) } , | x | { let _ = x . __expect ("\\") ? ; let escape = match x . ESCAPE () { Some (value) => value , None => return x . __error ("<ESCAPE>") , } ; Some (Chunk :: Escape (escape)) }] ; self . __lex (RULES) } pub fn BOOL (& mut self) -> Option < Bool > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < Bool , 2usize > = [| x | { let _ = x . __expect ("true") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Bool :: True) } , | x | { let _ = x . __expect ("false") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (Bool :: False) }] ; self . __lex (RULES) } pub fn UNDERSCORE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("_") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn BREAK (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("break") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn CONTINUE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("continue") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn FOR (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("for") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn IN (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("in") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn IF (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("if") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn LOOP (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("loop") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn RETURN (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("return") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn WHILE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("while") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn ELSE (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("else") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn OR (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("or") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn AND (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("and") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn NOT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } const RULES : super :: Rules < () , 1usize > = [| x | { let _ = x . __expect ("not") ? ; let _ = x . __lookahead (| x | x . TAIL () , false) ? ; Some (()) }] ; self . __lex (RULES) } pub fn IDENT (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , (1usize , 48usize ..= 57usize) => 1usize , (1usize , 65usize ..= 90usize) => 1usize , (1usize , 95usize ..= 95usize) => 1usize , (1usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; let start = self . stream . cursor ; let strict = self . stream . strict ; if let Some (& (end , cache)) = self . memo . IDENT . get (& (start , strict)) { self . stream . cursor = end ; return cache ; } self . stream . trim () ; let result = self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) ; let end = self . stream . cursor ; self . memo . IDENT . insert ((start , strict) , (end , result)) ; result } pub fn TAIL (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 57usize) => 1usize , (0usize , 65usize ..= 90usize) => 1usize , (0usize , 95usize ..= 95usize) => 1usize , (0usize , 97usize ..= 122usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn INT (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 48usize) => 1usize , (0usize , 49usize ..= 57usize) => 2usize , (2usize , 48usize ..= 57usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , true , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn FLOAT (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 48usize) => 1usize , (0usize , 49usize ..= 57usize) => 2usize , (2usize , 46usize ..= 46usize) => 3usize , (2usize , 48usize ..= 57usize) => 2usize , (3usize , 48usize ..= 57usize) => 4usize , (4usize , 48usize ..= 57usize) => 4usize , (1usize , 46usize ..= 46usize) => 5usize , (5usize , 48usize ..= 57usize) => 6usize , (6usize , 48usize ..= 57usize) => 6usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 7usize] = [false , false , false , false , true , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn SLICE (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 0usize ..= 33usize) => 1usize , (0usize , 35usize ..= 91usize) => 1usize , (0usize , 93usize ..= 18446744073709551615usize) => 1usize , (1usize , 0usize ..= 33usize) => 1usize , (1usize , 35usize ..= 91usize) => 1usize , (1usize , 93usize ..= 18446744073709551615usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn HEX (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 48usize ..= 57usize) => 0usize , (0usize , 97usize ..= 102usize) => 0usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 1usize] = [true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn ESCAPE (& mut self) -> Option < usize > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 39usize ..= 39usize) => 1usize , (0usize , 92usize ..= 92usize) => 1usize , (0usize , 110usize ..= 110usize) => 1usize , (0usize , 114usize ..= 114usize) => 1usize , (0usize , 116usize ..= 116usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . map (| s | self . intern . id (s)) } pub fn WS (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 2usize] = [false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } pub fn COMMENT (& mut self) -> Option < () > { if self . snapshot . is_some () { return None ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 47usize ..= 47usize) => 1usize , (1usize , 47usize ..= 47usize) => 2usize , (2usize , 0usize ..= 9usize) => 2usize , (2usize , 11usize ..= 18446744073709551615usize) => 2usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 3usize] = [false , false , true] ; self . stream . trim () ; self . stream . dfa (transition , ACCEPTANCE) . and (Some (())) } } # [allow (unused)] impl super :: Stream { pub fn trim (& mut self) { if self . strict { return ; } fn transition (s : usize , c : char) -> Option < usize > { let s = match (s , c as usize) { (0usize , 9usize ..= 9usize) => 1usize , (0usize , 10usize ..= 10usize) => 1usize , (0usize , 13usize ..= 13usize) => 1usize , (0usize , 32usize ..= 32usize) => 1usize , (0usize , 47usize ..= 47usize) => 2usize , (2usize , 47usize ..= 47usize) => 3usize , (3usize , 0usize ..= 9usize) => 3usize , (3usize , 11usize ..= 18446744073709551615usize) => 3usize , (1usize , 9usize ..= 9usize) => 1usize , (1usize , 10usize ..= 10usize) => 1usize , (1usize , 13usize ..= 13usize) => 1usize , (1usize , 32usize ..= 32usize) => 1usize , _ => return None , } ; Some (s) } const ACCEPTANCE : [bool ; 4usize] = [false , true , false , true] ; loop { if self . dfa (transition , ACCEPTANCE) . is_none () { break ; } } } }